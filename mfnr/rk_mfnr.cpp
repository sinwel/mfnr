//
/////////////////////////////////////////////////////////////////////////
// File: rk_mfnr.c
// Desc: Implementation of MFNR
// 
// Date: Revised by yousf 20160824
// 
//////////////////////////////////////////////////////////////////////////
////-------- Header files
//
#include "rk_mfnr.h"         // MFNR: Multi-Frame Noise Reduction


//// DSP Memory: 128KB
DATA_MFNR_INT_DSP  RK_U8 	g_DspBuf[DSP_MEM_SIZE];

// classMFNR
DATA_MFNR_EX 	classMFNR	g_mfnrProcessor;


DATA_MFNR_EX extern unsigned short  cure_table[24][961];                                  
DATA_MFNR_EX extern  unsigned short tab_16banks[481*32];
                                                                           

CODE_MFNR_EX                                                                    
void lutWdrTable(unsigned short *table, unsigned short exp_times)            
{                                                                            
	                                                                            
	int	idx;                                                                    
	int	i;                                                                      
	                                                                            
	if (exp_times>24)                                                           
	{                                                                           
		exp_times = 24;                                                           
	}                                                                           
	exp_times = exp_times-1;                                                    
	                                                                            
	idx = exp_times;                                                            
	//if(exp_times == idx)                                                      
	{                                                                           
		for(i=0;i<961;i++)                                                        
		{                                                                         
			table[i] = cure_table[idx][i];                                          
		}                                                                         
	}                                                                           
	/*                                                                          
	else                                                                        
	{                                                                           
		float  s1,s2;                                                             
		                                                                          
		s1 = idx+1-exp_times;                                                     
		s2 = exp_times-idx;                                                       
		for(i=0;i<961;i++)                                                        
		{                                                                         
			table[i] = (float)cure_table[idx][i]*s1+(float)cure_table[idx+1][i]*s2; 
		}                                                                         
	}*/                                                                         
}                                                                            

#include <stdlib.h>
CODE_MFNR_EX
void writeFile(RK_U16 *data, int Num, char* FileName)
{
	/*
	FILE* fp = fopen(FileName,"w");
	for ( int i = 0 ; i < Num; i++ )
	{
		fprintf(fp,"%6d,", *data++);
		if ( (i+1)%256 == 0 )
		{
			fprintf(fp,"\n");
		}
	}

	fclose(fp);
	*/
}

//////////////////////////////////////////////////////////////////////////
////-------- Data Table
//
////---- Region4IndexTable: Revised by yousf 20160801
DATA_MFNR_EX RK_U8 Region4IndexTable[4*NUM_R4IT_CHOICE] = {
    0,  3, 12, 15,  0,  2, 12, 15,  0,  3,  8, 15,  0,  3, 11, 12,  0,  3, 12, 14,  0,  3, 13, 15,  0,  7, 12, 15,  1,  3, 12, 15,  3,  4, 12, 15,  0,  2, 11, 12, 
    0,  3,  8, 14,  0,  3, 11, 13,  0,  7, 12, 14,  1,  3,  8, 15,  1,  7, 12, 15,  2,  4, 12, 15,  3,  4, 13, 15,  0,  1, 12, 15,  0,  2,  8, 15,  0,  2, 12, 14, 
    0,  2, 13, 15,  0,  3,  4, 15,  0,  3,  7, 12,  0,  3,  8, 11,  0,  3,  9, 15,  0,  3, 10, 12,  0,  3, 12, 13,  0,  3, 13, 14,  0,  3, 14, 15,  0,  6, 12, 15, 
    0,  7,  8, 15,  0,  7, 11, 12,  0,  7, 13, 15,  0, 11, 12, 15,  1,  2, 12, 15,  1,  3, 11, 12,  1,  3, 12, 14,  1,  3, 13, 15,  2,  3, 12, 15,  3,  4,  8, 15, 
    3,  4, 11, 12,  3,  4, 12, 14,  3,  5, 12, 15,  3,  8, 12, 15,  4,  7, 12, 15,  0,  1, 11, 12,  0,  2,  7, 12,  0,  2, 11, 13,  0,  3,  4, 14,  0,  3,  7, 13, 
    0,  3,  8, 13,  0,  3, 11, 14,  0,  7,  8, 14,  0,  7, 12, 13,  0, 11, 12, 14,  1,  3,  4, 15,  1,  3,  8, 14,  1,  4, 12, 15,  1,  7,  8, 15,  1,  7, 12, 14, 
    1, 11, 12, 15,  2,  3,  8, 15,  2,  4, 11, 12,  2,  4, 13, 15,  2,  7, 12, 15,  2,  8, 12, 15,  3,  4, 11, 13,  3,  4, 14, 15,  3,  8, 13, 15,  0,  1,  7, 12, 
    0,  2,  7, 13,  0,  2,  8, 11,  0,  2,  8, 14,  0,  2, 10, 12,  0,  3,  4, 13,  0,  3,  7, 14,  0,  3,  8, 10,  0,  3,  9, 11,  0,  3,  9, 14,  0,  3, 10, 13, 
    0,  6, 11, 12,  0,  6, 12, 14,  0,  7,  8, 13,  0,  7, 10, 12,  0,  7, 11, 13,  0,  7, 13, 14,  0, 11, 12, 13,  1,  2,  8, 15,  1,  2, 11, 12,  1,  3,  4, 14, 
    1,  3,  8, 11,  1,  3,  9, 15,  1,  3, 11, 13,  1,  4, 11, 12,  1,  6, 12, 15,  1,  7,  8, 14,  1,  7, 11, 12,  1,  7, 13, 15,  1,  8, 12, 15,  1, 11, 12, 14, 
    2,  3,  4, 15,  2,  4,  8, 15,  2,  4, 11, 13,  2,  4, 12, 14,  2,  5, 12, 15,  2,  7,  8, 15,  2,  8, 13, 15,  2, 11, 12, 15,  3,  4,  8, 14,  3,  4,  9, 15, 
    3,  4, 11, 14,  3,  4, 13, 14,  3,  5,  8, 15,  3,  5, 13, 15,  3,  8, 14, 15,  4,  6, 12, 15,  4,  7, 12, 14,  4,  7, 13, 15,  5,  7, 12, 15,  0,  1,  3, 12, 
    0,  1,  3, 13,  0,  1,  3, 14,  0,  1,  3, 15,  0,  1,  7, 13,  0,  1,  8, 15,  0,  1, 11, 13,  0,  1, 12, 14,  0,  1, 13, 15,  0,  2,  3, 12,  0,  2,  3, 13, 
    0,  2,  3, 14,  0,  2,  3, 15,  0,  2,  4, 15,  0,  2,  7, 14,  0,  2,  9, 15,  0,  2, 11, 14,  0,  2, 12, 13,  0,  2, 13, 14,  0,  2, 14, 15,  0,  3,  4, 11, 
    0,  3,  4, 12,  0,  3,  5, 12,  0,  3,  5, 13,  0,  3,  5, 14,  0,  3,  5, 15,  0,  3,  6, 12,  0,  3,  6, 13,  0,  3,  6, 14,  0,  3,  6, 15,  0,  3,  7,  8, 
    0,  3,  7, 15,  0,  3,  8, 12,  0,  3,  9, 12,  0,  3,  9, 13,  0,  3, 10, 14,  0,  3, 10, 15,  0,  3, 11, 15,  0,  4,  7, 12,  0,  4,  7, 13,  0,  4,  7, 14, 
    0,  4,  7, 15,  0,  4, 11, 12,  0,  4, 12, 15,  0,  5,  7, 12,  0,  5, 11, 12,  0,  5, 12, 15,  0,  6,  7, 12,  0,  6,  8, 15,  0,  6, 13, 15,  0,  7,  8, 11, 
    0,  7,  8, 12,  0,  7,  9, 12,  0,  7,  9, 15,  0,  7, 14, 15,  0,  8, 11, 12,  0,  8, 11, 13,  0,  8, 11, 14,  0,  8, 11, 15,  0,  8, 12, 15,  0,  9, 11, 12, 
    0,  9, 12, 15,  0, 10, 11, 12,  0, 10, 12, 15,  0, 11, 13, 15,  0, 12, 13, 15,  0, 12, 14, 15,  1,  2, 12, 14,  1,  2, 13, 15,  1,  3,  4, 13,  1,  3,  7, 12, 
    1,  3,  8, 13,  1,  3, 10, 12,  1,  3, 12, 13,  1,  3, 13, 14,  1,  3, 14, 15,  1,  4,  7, 12,  1,  4,  7, 13,  1,  4,  7, 14,  1,  4,  7, 15,  1,  4, 11, 13, 
    1,  4, 13, 15,  1,  5, 12, 15,  1,  7,  8, 13,  1,  7, 12, 13,  1,  8, 11, 12,  1,  8, 11, 13,  1,  8, 11, 14,  1,  8, 11, 15,  1,  8, 13, 15,  1,  9, 12, 15, 
    1, 10, 12, 15,  1, 11, 12, 13,  1, 12, 13, 15,  1, 12, 14, 15,  2,  3,  4, 14,  2,  3,  8, 14,  2,  3, 11, 12,  2,  3, 12, 14,  2,  3, 13, 15,  2,  4,  7, 12, 
    2,  4,  7, 13,  2,  4,  7, 14,  2,  4,  7, 15,  2,  4, 11, 14,  2,  4, 14, 15,  2,  6, 12, 15,  2,  7,  8, 14,  2,  7, 12, 14,  2,  8, 11, 12,  2,  8, 11, 13, 
    2,  8, 11, 14,  2,  8, 11, 15,  2,  8, 14, 15,  2,  9, 12, 15,  2, 10, 12, 15,  2, 11, 12, 14,  2, 12, 13, 15,  2, 12, 14, 15,  3,  4,  5, 15,  3,  4,  6, 15, 
    3,  4,  7, 12,  3,  4,  7, 13,  3,  4,  7, 14,  3,  4,  7, 15,  3,  4,  8, 11,  3,  4, 10, 12,  3,  4, 10, 15,  3,  4, 11, 15,  3,  4, 12, 13,  3,  5, 11, 12, 
    3,  5, 12, 14,  3,  6,  8, 15,  3,  6, 12, 15,  3,  7,  8, 15,  3,  7, 12, 15,  3,  8,  9, 15,  3,  8, 10, 15,  3,  8, 11, 12,  3,  8, 11, 13,  3,  8, 11, 14, 
    3,  8, 11, 15,  3,  8, 12, 14,  3,  9, 12, 15,  3, 10, 12, 15,  3, 11, 12, 15,  3, 12, 13, 15,  3, 12, 14, 15,  4,  7,  8, 15,  4,  7, 11, 12,  4, 11, 12, 15, 
    7,  8, 12, 15,  0,  1,  7, 14,  0,  1,  8, 11,  0,  1, 10, 12,  0,  2,  4, 14,  0,  2,  6, 12,  0,  2,  7,  8,  0,  2,  7, 15,  0,  2,  8, 10,  0,  2,  8, 13, 
    0,  2,  9, 11,  0,  2, 10, 13,  0,  3,  4, 10,  0,  3,  7,  9,  0,  3,  8,  9,  0,  3,  9, 10,  0,  3, 10, 11,  0,  4, 11, 13,  0,  5,  7, 13,  0,  6,  7, 13, 
    0,  6,  8, 14,  0,  6, 10, 12,  0,  6, 11, 13,  0,  6, 12, 13,  0,  7,  8, 10,  0,  7,  9, 13,  0,  7,  9, 14,  0,  7, 10, 13,  0,  7, 11, 14,  0,  8, 13, 15, 
    0, 10, 12, 14,  0, 11, 13, 14,  1,  2,  4, 15,  1,  2,  7, 12,  1,  2,  8, 11,  1,  2,  8, 14,  1,  2, 11, 13,  1,  3,  4, 11,  1,  3,  4, 12,  1,  3,  5, 15, 
    1,  3,  7, 13,  1,  3,  8, 10,  1,  3,  9, 11,  1,  3,  9, 14,  1,  3, 11, 14,  1,  4,  8, 15,  1,  4, 11, 14,  1,  4, 12, 14,  1,  5, 11, 12,  1,  6,  8, 15, 
    1,  6, 11, 12,  1,  6, 12, 14,  1,  7,  8, 11,  1,  7,  8, 12,  1,  7,  9, 15,  1,  7, 10, 12,  1,  7, 11, 13,  1,  7, 13, 14,  1,  8, 14, 15,  1,  9, 11, 12, 
    1, 10, 11, 12,  1, 11, 13, 15,  2,  3,  4, 13,  2,  3,  8, 11,  2,  3,  9, 15,  2,  4,  8, 11,  2,  4,  8, 14,  2,  4,  9, 15,  2,  4, 10, 12,  2,  4, 11, 15, 
    2,  4, 13, 14,  2,  5,  8, 15,  2,  5, 11, 12,  2,  5, 13, 15,  2,  6,  8, 15,  2,  7,  8, 13,  2,  7, 11, 12,  2,  7, 13, 15,  2,  8,  9, 15,  2,  8, 10, 15, 
    2,  8, 12, 14,  2, 11, 12, 13,  3,  4,  5, 14,  3,  4,  6, 14,  3,  4,  8, 13,  3,  4,  9, 11,  3,  4,  9, 14,  3,  4, 10, 13,  3,  4, 10, 14,  3,  5,  8, 14, 
    3,  5,  9, 15,  3,  5, 11, 13,  3,  5, 14, 15,  3,  7,  8, 14,  3,  8, 13, 14,  3,  9, 13, 15,  3, 11, 12, 14,  4,  5, 12, 15,  4,  6, 11, 12,  4,  6, 12, 14, 
    4,  6, 13, 15,  4,  7,  8, 14,  4,  7, 11, 13,  4,  7, 12, 13,  4,  7, 13, 14,  4,  7, 14, 15,  4, 11, 12, 14,  5,  6, 12, 15,  5,  7,  8, 15,  5,  7, 12, 14, 
    5,  7, 13, 15,  5, 11, 12, 15,  6,  7, 12, 15,  6,  8, 12, 15,  7,  8, 13, 15,  0,  1,  6, 12,  0,  1,  7,  8,  0,  1,  7, 15,  0,  1,  8, 14,  0,  1, 11, 14, 
    0,  2,  4, 11,  0,  2,  4, 13,  0,  2,  6, 13,  0,  2,  7,  9,  0,  2,  9, 12,  0,  2,  9, 14,  0,  2, 11, 15,  0,  3,  4,  9,  0,  3,  5, 11,  0,  3,  6,  8, 
    0,  3,  7, 10,  0,  4, 11, 14,  0,  4, 13, 15,  0,  5,  7, 14,  0,  5, 11, 13,  0,  5, 12, 14,  0,  6,  7, 14,  0,  6,  8, 11,  0,  6,  8, 13,  0,  6, 13, 14, 
    0,  7,  8,  9,  0,  7,  9, 11,  0,  7, 10, 14,  0,  8, 14, 15,  0,  9, 11, 13,  0, 10, 11, 13,  0, 10, 12, 13,  1,  2,  4, 14,  1,  2,  7, 13,  1,  2,  9, 15, 
    1,  2, 10, 12,  1,  3,  4, 10,  1,  3,  5, 14,  1,  3,  7,  8,  1,  3,  7, 14,  1,  3,  8, 12,  1,  3, 10, 13,  1,  3, 10, 15,  1,  4,  8, 11,  1,  4, 10, 12, 
    1,  4, 11, 15,  1,  4, 14, 15,  1,  5,  7, 12,  1,  5,  8, 15,  1,  6,  7, 12,  1,  6,  8, 14,  1,  6, 13, 15,  1,  7,  8, 10,  1,  7,  9, 12,  1,  7,  9, 14, 
    1,  7, 14, 15,  1,  8,  9, 15,  1,  8, 10, 15,  1,  8, 12, 14,  1, 10, 12, 14,  1, 11, 13, 14,  2,  3,  4, 11,  2,  3,  4, 12,  2,  3,  5, 15,  2,  3,  8, 13, 
    2,  3, 11, 13,  2,  4,  5, 15,  2,  4,  6, 15,  2,  4,  9, 11,  2,  4, 10, 13,  2,  4, 10, 15,  2,  4, 12, 13,  2,  5, 11, 13,  2,  5, 12, 14,  2,  6, 11, 12, 
    2,  7,  8, 11,  2,  7,  8, 12,  2,  7,  9, 15,  2,  7, 12, 13,  2,  8, 13, 14,  2,  9, 11, 12,  2,  9, 13, 15,  2, 10, 11, 12,  2, 11, 13, 15,  3,  4,  5, 13, 
    3,  4,  6, 13,  3,  4,  8, 10,  3,  4,  9, 13,  3,  4, 10, 11,  3,  5,  8, 11,  3,  5, 11, 14,  3,  5, 13, 14,  3,  6,  8, 14,  3,  6, 13, 15,  3,  7,  8, 13, 
    3,  7, 12, 14,  3,  8,  9, 14,  3,  8, 10, 14,  3,  9, 14, 15,  3, 11, 12, 13,  4,  5, 11, 12,  4,  6,  8, 15,  4,  6, 11, 13,  4,  7,  8, 13,  4,  7,  9, 15, 
    4,  7, 10, 12,  4,  7, 11, 14,  4, 10, 12, 15,  4, 11, 12, 13,  4, 11, 13, 15,  5,  7,  8, 14,  5,  7, 11, 12,  5,  8, 12, 15,  5, 11, 12, 14,  6,  7,  8, 15, 
    6,  8, 13, 15,  6, 11, 12, 15,  7,  8, 12, 14,  7,  8, 14, 15,  7,  9, 12, 15,  0,  1,  2, 12,  0,  1,  2, 13,  0,  1,  2, 14,  0,  1,  2, 15,  0,  1,  3,  8, 
    0,  1,  3,  9,  0,  1,  3, 10,  0,  1,  3, 11,  0,  1,  4, 15,  0,  1,  6, 13,  0,  1,  7,  9,  0,  1,  8, 10,  0,  1,  9, 11,  0,  1,  9, 15,  0,  1, 10, 13, 
    0,  1, 12, 13,  0,  1, 13, 14,  0,  1, 14, 15,  0,  2,  3,  8,  0,  2,  3,  9,  0,  2,  3, 10,  0,  2,  3, 11,  0,  2,  4, 10,  0,  2,  4, 12,  0,  2,  5, 12, 
    0,  2,  5, 13,  0,  2,  5, 14,  0,  2,  5, 15,  0,  2,  6,  8,  0,  2,  6, 14,  0,  2,  6, 15,  0,  2,  7, 10,  0,  2,  8,  9,  0,  2,  8, 12,  0,  2,  9, 10, 
    0,  2,  9, 13,  0,  2, 10, 11,  0,  2, 10, 14,  0,  2, 10, 15,  0,  3,  4,  7,  0,  3,  4,  8,  0,  3,  5,  8,  0,  3,  5,  9,  0,  3,  5, 10,  0,  3,  6,  9, 
    0,  3,  6, 10,  0,  3,  6, 11,  0,  3,  7, 11,  0,  4,  6, 12,  0,  4,  6, 13,  0,  4,  6, 14,  0,  4,  6, 15,  0,  4,  7,  8,  0,  4,  7,  9,  0,  4,  7, 10, 
    0,  4,  7, 11,  0,  4,  8, 11,  0,  4,  8, 15,  0,  4, 10, 12,  0,  4, 11, 15,  0,  4, 12, 14,  0,  5,  6, 12,  0,  5,  7,  8,  0,  5,  7, 15,  0,  5,  8, 11, 
    0,  5,  8, 15,  0,  5, 10, 12,  0,  5, 13, 15,  0,  6,  7,  8,  0,  6,  7, 15,  0,  6,  8, 10,  0,  6,  8, 12,  0,  6,  9, 12,  0,  6,  9, 15,  0,  6, 10, 13, 
    0,  6, 11, 14,  0,  6, 14, 15,  0,  7,  9, 10,  0,  7, 10, 15,  0,  7, 11, 15,  0,  8,  9, 11,  0,  8,  9, 15,  0,  8, 10, 11,  0,  8, 10, 12,  0,  8, 10, 13, 
    0,  8, 10, 14,  0,  8, 10, 15,  0,  8, 12, 14,  0,  9, 10, 12,  0,  9, 11, 14,  0,  9, 11, 15,  0,  9, 12, 14,  0,  9, 13, 15,  0, 10, 13, 15,  0, 11, 14, 15, 
    0, 12, 13, 14,  0, 13, 14, 15,  1,  2,  3, 12,  1,  2,  3, 13,  1,  2,  3, 14,  1,  2,  3, 15,  1,  2,  4, 11,  1,  2,  4, 13,  1,  2,  7,  8,  1,  2,  7, 14, 
    1,  2,  8, 10,  1,  2,  8, 13,  1,  2,  9, 11,  1,  2, 11, 14,  1,  2, 12, 13,  1,  2, 13, 14,  1,  2, 14, 15,  1,  3,  4,  9,  1,  3,  5, 11,  1,  3,  5, 12, 
    1,  3,  5, 13,  1,  3,  6, 12,  1,  3,  6, 13,  1,  3,  6, 14,  1,  3,  6, 15,  1,  3,  7,  9,  1,  3,  7, 15,  1,  3,  8,  9,  1,  3,  9, 10,  1,  3,  9, 12, 
    1,  3,  9, 13,  1,  3, 10, 11,  1,  3, 10, 14,  1,  3, 11, 15,  1,  4,  6, 12,  1,  4,  6, 13,  1,  4,  6, 14,  1,  4,  6, 15,  1,  4,  7,  8,  1,  4,  7,  9, 
    1,  4,  7, 10,  1,  4,  7, 11,  1,  4,  8, 14,  1,  4,  9, 11,  1,  4,  9, 15,  1,  4, 10, 13,  1,  4, 13, 14,  1,  5,  7, 13,  1,  5,  7, 14,  1,  5,  7, 15, 
    1,  5,  8, 11,  1,  5, 11, 13,  1,  5, 12, 14,  1,  5, 13, 15,  1,  6,  7, 13,  1,  6,  8, 11,  1,  6,  8, 13,  1,  6, 10, 12,  1,  6, 11, 13,  1,  6, 12, 13, 
    1,  7,  8,  9,  1,  7,  9, 11,  1,  7,  9, 13,  1,  7, 10, 13,  1,  7, 11, 14,  1,  8,  9, 11,  1,  8, 10, 11,  1,  8, 10, 12,  1,  8, 10, 13,  1,  8, 10, 14, 
    1,  8, 13, 14,  1,  9, 11, 13,  1,  9, 11, 14,  1,  9, 11, 15,  1,  9, 12, 14,  1,  9, 13, 15,  1, 10, 11, 13,  1, 10, 12, 13,  1, 10, 13, 15,  1, 12, 13, 14, 
    1, 13, 14, 15,  2,  3,  4, 10,  2,  3,  5, 14,  2,  3,  7, 12,  2,  3,  8, 10,  2,  3,  9, 11,  2,  3,  9, 14,  2,  3, 10, 12,  2,  3, 12, 13,  2,  3, 13, 14, 
    2,  3, 14, 15,  2,  4,  5, 14,  2,  4,  6, 12,  2,  4,  6, 13,  2,  4,  6, 14,  2,  4,  7,  8,  2,  4,  7,  9,  2,  4,  7, 10,  2,  4,  7, 11,  2,  4,  8, 10, 
    2,  4,  8, 13,  2,  4,  9, 14,  2,  4, 10, 11,  2,  4, 10, 14,  2,  5,  7, 12,  2,  5,  7, 13,  2,  5,  7, 14,  2,  5,  7, 15,  2,  5,  8, 11,  2,  5,  8, 14, 
    2,  5,  9, 15,  2,  5, 11, 14,  2,  5, 14, 15,  2,  6,  8, 11,  2,  6,  8, 14,  2,  6, 12, 14,  2,  6, 13, 15,  2,  7,  8, 10,  2,  7,  9, 14,  2,  7, 10, 12, 
    2,  7, 11, 13,  2,  7, 13, 14,  2,  8,  9, 11,  2,  8,  9, 14,  2,  8, 10, 11,  2,  8, 10, 12,  2,  8, 10, 13,  2,  8, 10, 14,  2,  9, 11, 13,  2,  9, 11, 14, 
    2,  9, 11, 15,  2,  9, 12, 14,  2,  9, 14, 15,  2, 10, 12, 14,  2, 10, 13, 15,  2, 11, 13, 14,  2, 12, 13, 14,  2, 13, 14, 15,  3,  4,  5, 11,  3,  4,  5, 12, 
    3,  4,  6, 11,  3,  4,  6, 12,  3,  4,  7,  8,  3,  4,  7,  9,  3,  4,  7, 10,  3,  4,  7, 11,  3,  4,  8, 12,  3,  4,  9, 10,  3,  4,  9, 12,  3,  5,  6, 15, 
    3,  5,  7, 12,  3,  5,  7, 13,  3,  5,  7, 14,  3,  5,  7, 15,  3,  5,  8, 13,  3,  5,  9, 11,  3,  5,  9, 14,  3,  5, 10, 12,  3,  5, 10, 15,  3,  5, 11, 15, 
    3,  5, 12, 13,  3,  6,  8, 11,  3,  6,  9, 15,  3,  6, 11, 12,  3,  6, 12, 14,  3,  7,  8, 11,  3,  7,  8, 12,  3,  7,  9, 15,  3,  7, 11, 12,  3,  7, 13, 15, 
    3,  8,  9, 11,  3,  8, 10, 11,  3,  8, 10, 12,  3,  8, 10, 13,  3,  8, 12, 13,  3,  9, 10, 15,  3,  9, 11, 12,  3,  9, 11, 13,  3,  9, 11, 14,  3,  9, 11, 15, 
    3,  9, 12, 14,  3, 10, 11, 12,  3, 10, 12, 14,  3, 10, 13, 15,  3, 11, 13, 15,  3, 12, 13, 14,  3, 13, 14, 15,  4,  5,  7, 12,  4,  5,  7, 13,  4,  5,  7, 14, 
    4,  5,  7, 15,  4,  5, 11, 13,  4,  5, 12, 14,  4,  5, 13, 15,  4,  6,  7, 12,  4,  6,  7, 13,  4,  6,  7, 14,  4,  6,  7, 15,  4,  6,  8, 14,  4,  6, 10, 12, 
    4,  6, 11, 14,  4,  6, 12, 13,  4,  6, 13, 14,  4,  6, 14, 15,  4,  7,  8, 11,  4,  7,  8, 12,  4,  7,  9, 12,  4,  7,  9, 13,  4,  7,  9, 14,  4,  7, 10, 13, 
    4,  7, 10, 14,  4,  7, 10, 15,  4,  7, 11, 15,  4,  8, 11, 12,  4,  8, 11, 13,  4,  8, 11, 14,  4,  8, 11, 15,  4,  8, 12, 15,  4,  9, 11, 12,  4,  9, 12, 15, 
    4, 10, 11, 12,  4, 10, 12, 14,  4, 11, 13, 14,  4, 12, 13, 15,  4, 12, 14, 15,  5,  6,  8, 15,  5,  6, 11, 12,  5,  6, 12, 14,  5,  6, 13, 15,  5,  7,  8, 13, 
    5,  7,  9, 15,  5,  7, 11, 13,  5,  7, 12, 13,  5,  7, 13, 14,  5,  7, 14, 15,  5,  8, 11, 12,  5,  8, 11, 13,  5,  8, 11, 14,  5,  8, 11, 15,  5,  8, 13, 15, 
    5,  9, 12, 15,  5, 10, 12, 15,  5, 11, 12, 13,  5, 11, 13, 15,  5, 12, 13, 15,  5, 12, 14, 15,  6,  7,  8, 14,  6,  7, 12, 14,  6,  7, 13, 15,  6,  8, 11, 12, 
    6,  8, 11, 13,  6,  8, 11, 14,  6,  8, 11, 15,  6,  8, 12, 14,  6,  8, 14, 15,  6,  9, 12, 15,  6, 10, 12, 15,  6, 11, 12, 14,  6, 12, 13, 15,  6, 12, 14, 15, 
    7,  8,  9, 15,  7,  8, 10, 15,  7,  8, 11, 12,  7,  8, 11, 13,  7,  8, 11, 14,  7,  8, 11, 15,  7,  8, 13, 14,  7,  9, 13, 15,  7, 10, 12, 15,  7, 11, 12, 15, 
    7, 12, 13, 15,  7, 12, 14, 15,  8, 11, 12, 15,  0,  1,  4, 11,  0,  1,  4, 14,  0,  1,  6,  8,  0,  1,  6, 14,  0,  1,  7, 10,  0,  1,  8, 13,  0,  1,  9, 12, 
    0,  1, 11, 15,  0,  2,  4,  7,  0,  2,  4,  9,  0,  2,  5, 11,  0,  2,  6,  9,  0,  2,  7, 11,  0,  3,  4,  6,  0,  3,  5,  7,  0,  4,  9, 11,  0,  4, 10, 13, 
    0,  4, 14, 15,  0,  5,  6, 13,  0,  5,  7,  9,  0,  5,  8, 14,  0,  5, 11, 14,  0,  5, 12, 13,  0,  6,  7,  9,  0,  6,  8,  9,  0,  6,  9, 11,  0,  6,  9, 13, 
    0,  6,  9, 14,  0,  7, 10, 11,  0,  8, 13, 14,  0, 10, 11, 14,  0, 10, 13, 14,  1,  2,  4, 10,  1,  2,  4, 12,  1,  2,  5, 15,  1,  2,  6, 12,  1,  2,  7,  9, 
    1,  2,  7, 15,  1,  2,  9, 14,  1,  2, 10, 13,  1,  3,  4,  7,  1,  3,  4,  8,  1,  3,  5, 10,  1,  3,  6,  8,  1,  3,  7, 10,  1,  4,  5, 15,  1,  4,  8, 10, 
    1,  4, 10, 11,  1,  4, 10, 14,  1,  4, 10, 15,  1,  4, 12, 13,  1,  5,  7,  8,  1,  5,  8, 14,  1,  5, 10, 12,  1,  5, 11, 14,  1,  6,  7,  8,  1,  6,  7, 14, 
    1,  6,  8, 10,  1,  6,  8, 12,  1,  6,  9, 15,  1,  6, 13, 14,  1,  7,  9, 10,  1,  7, 10, 14,  1,  7, 10, 15,  1,  8,  9, 14,  1,  9, 10, 12,  1,  9, 14, 15, 
    1, 11, 14, 15,  2,  3,  4,  9,  2,  3,  5, 11,  2,  3,  5, 13,  2,  3,  7,  8,  2,  3,  7, 13,  2,  3,  8, 12,  2,  3, 10, 15,  2,  3, 11, 14,  2,  4,  5, 11, 
    2,  4,  5, 13,  2,  4,  6, 11,  2,  4,  9, 10,  2,  4,  9, 12,  2,  4,  9, 13,  2,  5,  9, 11,  2,  5, 10, 12,  2,  5, 11, 15,  2,  5, 13, 14,  2,  6,  7, 12, 
    2,  6,  8, 13,  2,  6,  9, 15,  2,  6, 11, 13,  2,  7,  8,  9,  2,  7,  9, 11,  2,  7,  9, 12,  2,  7,  9, 13,  2,  7, 14, 15,  2,  8, 12, 13,  2,  9, 10, 15, 
    2, 10, 11, 13,  2, 10, 12, 13,  3,  4,  5, 10,  3,  4,  6, 10,  3,  4,  8,  9,  3,  5,  6, 14,  3,  5,  8, 10,  3,  5, 10, 11,  3,  5, 10, 13,  3,  5, 10, 14, 
    3,  6,  8, 13,  3,  6, 11, 13,  3,  6, 14, 15,  3,  7,  8, 10,  3,  7,  9, 14,  3,  7, 12, 13,  3,  8,  9, 13,  3,  9, 13, 14,  3, 11, 13, 14,  4,  5,  8, 15, 
    4,  5, 10, 12,  4,  5, 11, 14,  4,  6,  8, 11,  4,  6,  8, 13,  4,  6,  9, 15,  4,  6, 10, 13,  4,  6, 11, 15,  4,  7,  8, 10,  4,  7,  9, 11,  4,  8, 13, 15, 
    4,  9, 11, 13,  4, 10, 11, 13,  4, 10, 12, 13,  4, 10, 13, 15,  4, 11, 14, 15,  5,  6,  8, 14,  5,  6, 11, 13,  5,  7,  8, 11,  5,  7,  8, 12,  5,  7,  9, 14, 
    5,  7, 10, 12,  5,  7, 11, 14,  5,  8, 12, 14,  5,  8, 14, 15,  5,  9, 11, 12,  5, 10, 11, 12,  5, 10, 12, 14,  5, 11, 13, 14,  6,  7,  8, 13,  6,  7,  9, 15, 
    6,  7, 11, 12,  6,  8,  9, 15,  6,  8, 10, 15,  6,  8, 13, 14,  6,  9, 13, 15,  6, 11, 12, 13,  6, 11, 13, 15,  7,  8,  9, 14,  7,  8, 10, 14,  7,  8, 12, 13, 
    7,  9, 12, 14,  7,  9, 14, 15,  7, 11, 12, 14,  8, 10, 12, 15,  8, 11, 12, 14,  8, 11, 13, 15,  9, 11, 12, 15,  0,  1,  2,  8,  0,  1,  2,  9,  0,  1,  2, 10, 
    0,  1,  2, 11,  0,  1,  4,  7,  0,  1,  4, 10,  0,  1,  4, 13,  0,  1,  5, 12,  0,  1,  6,  9,  0,  1,  6, 15,  0,  1,  7, 11,  0,  1,  8,  9,  0,  1,  9, 10, 
    0,  1,  9, 14,  0,  1, 10, 11,  0,  1, 10, 14,  0,  2,  4,  6,  0,  2,  4,  8,  0,  2,  5,  7,  0,  2,  5,  8,  0,  2,  5,  9,  0,  2,  5, 10,  0,  2,  6, 10, 
    0,  2,  6, 11,  0,  3,  4,  5,  0,  3,  5,  6,  0,  3,  6,  7,  0,  4,  6,  8,  0,  4,  6,  9,  0,  4,  6, 10,  0,  4,  6, 11,  0,  4,  8, 10,  0,  4,  8, 14, 
    0,  4,  9, 15,  0,  4, 10, 11,  0,  4, 10, 14,  0,  4, 13, 14,  0,  5,  6,  8,  0,  5,  6, 14,  0,  5,  7, 10,  0,  5,  7, 11,  0,  5,  8, 10,  0,  5,  8, 13, 
    0,  5,  9, 11,  0,  5,  9, 12,  0,  5, 10, 13,  0,  5, 13, 14,  0,  6,  7, 10,  0,  6,  9, 10,  0,  6, 10, 14,  0,  6, 11, 15,  0,  8,  9, 10,  0,  8,  9, 14, 
    0,  9, 10, 11,  0,  9, 10, 13,  0,  9, 12, 13,  0,  9, 14, 15,  1,  2,  3,  8,  1,  2,  3,  9,  1,  2,  3, 10,  1,  2,  3, 11,  1,  2,  4,  7,  1,  2,  4,  9, 
    1,  2,  5, 11,  1,  2,  5, 14,  1,  2,  6,  8,  1,  2,  6, 13,  1,  2,  7, 10,  1,  2,  8,  9,  1,  2,  8, 12,  1,  2,  9, 10,  1,  2,  9, 12,  1,  2, 10, 11, 
    1,  2, 10, 15,  1,  2, 11, 15,  1,  3,  4,  6,  1,  3,  5,  7,  1,  3,  5,  8,  1,  3,  5,  9,  1,  3,  6,  9,  1,  3,  6, 10,  1,  3,  6, 11,  1,  3,  7, 11, 
    1,  4,  5, 11,  1,  4,  5, 14,  1,  4,  6,  8,  1,  4,  6,  9,  1,  4,  6, 10,  1,  4,  6, 11,  1,  4,  8, 13,  1,  4,  9, 10,  1,  4,  9, 12,  1,  4,  9, 14, 
    1,  5,  6, 12,  1,  5,  7,  9,  1,  5,  7, 10,  1,  5,  7, 11,  1,  5,  8, 10,  1,  5,  9, 11,  1,  5,  9, 15,  1,  5, 11, 15,  1,  5, 14, 15,  1,  6,  7,  9, 
    1,  6,  7, 15,  1,  6,  8,  9,  1,  6,  9, 11,  1,  6,  9, 12,  1,  6,  9, 14,  1,  6, 10, 13,  1,  6, 11, 14,  1,  6, 14, 15,  1,  7, 10, 11,  1,  7, 11, 15, 
    1,  8,  9, 10,  1,  8, 12, 13,  1,  9, 10, 11,  1,  9, 10, 15,  1, 10, 11, 14,  1, 10, 13, 14,  2,  3,  4,  7,  2,  3,  4,  8,  2,  3,  5, 10,  2,  3,  5, 12, 
    2,  3,  6, 15,  2,  3,  7,  9,  2,  3,  7, 14,  2,  3,  8,  9,  2,  3,  9, 10,  2,  3,  9, 13,  2,  3, 10, 11,  2,  3, 10, 13,  2,  4,  5, 10,  2,  4,  5, 12, 
    2,  4,  6,  8,  2,  4,  6,  9,  2,  4,  6, 10,  2,  4,  8,  9,  2,  4,  8, 12,  2,  5,  6, 15,  2,  5,  7,  8,  2,  5,  7,  9,  2,  5,  7, 10,  2,  5,  7, 11, 
    2,  5,  8, 10,  2,  5,  8, 13,  2,  5,  9, 14,  2,  5, 10, 11,  2,  5, 10, 13,  2,  5, 10, 15,  2,  5, 12, 13,  2,  6,  7,  8,  2,  6,  7, 13,  2,  6,  8, 10, 
    2,  6,  8, 12,  2,  6,  9, 11,  2,  6, 10, 12,  2,  6, 12, 13,  2,  7,  9, 10,  2,  7, 10, 13,  2,  7, 10, 15,  2,  7, 11, 14,  2,  8,  9, 10,  2,  8,  9, 13, 
    2,  9, 10, 11,  2,  9, 10, 12,  2,  9, 13, 14,  2, 11, 14, 15,  3,  4,  5,  9,  3,  4,  6,  8,  3,  4,  6,  9,  3,  5,  6, 11,  3,  5,  6, 13,  3,  5,  7,  8, 
    3,  5,  7,  9,  3,  5,  7, 10,  3,  5,  7, 11,  3,  5,  8, 12,  3,  5,  9, 10,  3,  5,  9, 13,  3,  6,  8, 10,  3,  6,  9, 11,  3,  6,  9, 14,  3,  6, 10, 15, 
    3,  6, 11, 14,  3,  6, 13, 14,  3,  7,  8,  9,  3,  7,  9, 11,  3,  7,  9, 13,  3,  7, 10, 12,  3,  7, 11, 13,  3,  7, 13, 14,  3,  8,  9, 10,  3,  9, 10, 11, 
    3,  9, 10, 14,  3, 10, 11, 13,  3, 10, 12, 13,  3, 10, 14, 15,  4,  5,  6, 12,  4,  5,  6, 13,  4,  5,  6, 14,  4,  5,  6, 15,  4,  5,  8, 11,  4,  5,  8, 14, 
    4,  5, 10, 13,  4,  5, 11, 15,  4,  5, 12, 13,  4,  5, 13, 14,  4,  5, 14, 15,  4,  6,  8, 10,  4,  6,  8, 12,  4,  6,  9, 11,  4,  6,  9, 12,  4,  6,  9, 13, 
    4,  6,  9, 14,  4,  6, 10, 14,  4,  6, 10, 15,  4,  7,  8,  9,  4,  7,  9, 10,  4,  7, 10, 11,  4,  8, 10, 12,  4,  8, 10, 13,  4,  8, 10, 14,  4,  8, 10, 15, 
    4,  8, 12, 14,  4,  8, 14, 15,  4,  9, 10, 12,  4,  9, 11, 14,  4,  9, 11, 15,  4,  9, 12, 14,  4,  9, 13, 15,  4, 10, 11, 14,  4, 10, 13, 14,  4, 12, 13, 14, 
    4, 13, 14, 15,  5,  6,  7, 12,  5,  6,  7, 13,  5,  6,  7, 14,  5,  6,  7, 15,  5,  6,  8, 11,  5,  6,  8, 13,  5,  6,  9, 15,  5,  6, 10, 12,  5,  6, 11, 14, 
    5,  6, 12, 13,  5,  6, 13, 14,  5,  6, 14, 15,  5,  7,  8, 10,  5,  7,  9, 11,  5,  7,  9, 12,  5,  7,  9, 13,  5,  7, 10, 13,  5,  7, 10, 14,  5,  7, 10, 15, 
    5,  7, 11, 15,  5,  8,  9, 15,  5,  8, 10, 12,  5,  8, 10, 13,  5,  8, 10, 14,  5,  8, 10, 15,  5,  8, 13, 14,  5,  9, 11, 13,  5,  9, 11, 14,  5,  9, 11, 15, 
    5,  9, 12, 14,  5,  9, 13, 15,  5, 10, 11, 13,  5, 10, 12, 13,  5, 10, 13, 15,  5, 11, 14, 15,  5, 12, 13, 14,  5, 13, 14, 15,  6,  7,  8, 11,  6,  7,  8, 12, 
    6,  7,  9, 14,  6,  7, 11, 13,  6,  7, 12, 13,  6,  7, 13, 14,  6,  7, 14, 15,  6,  8,  9, 14,  6,  8, 10, 12,  6,  8, 10, 13,  6,  8, 10, 14,  6,  8, 12, 13, 
    6,  9, 11, 12,  6,  9, 11, 13,  6,  9, 11, 14,  6,  9, 11, 15,  6,  9, 12, 14,  6,  9, 14, 15,  6, 10, 11, 12,  6, 10, 12, 14,  6, 10, 13, 15,  6, 11, 13, 14, 
    6, 12, 13, 14,  6, 13, 14, 15,  7,  8,  9, 13,  7,  8, 10, 12,  7,  8, 10, 13,  7,  9, 10, 15,  7,  9, 11, 12,  7,  9, 11, 13,  7,  9, 11, 14,  7,  9, 11, 15, 
    7,  9, 13, 14,  7, 10, 12, 14,  7, 10, 13, 15,  7, 11, 12, 13,  7, 11, 13, 15,  7, 12, 13, 14,  7, 13, 14, 15,  8,  9, 12, 15,  8, 10, 12, 14,  8, 10, 13, 15, 
    8, 11, 12, 13,  8, 11, 13, 14,  8, 11, 14, 15,  9, 10, 12, 15,  9, 11, 12, 14,  9, 11, 13, 15, 10, 11, 12, 15,  0,  1,  3,  4,  0,  1,  3,  5,  0,  1,  3,  6, 
    0,  1,  3,  7,  0,  1,  4,  6,  0,  1,  4,  9,  0,  1,  4, 12,  0,  1,  5,  7,  0,  1,  5,  8,  0,  1,  5, 11,  0,  1,  5, 13,  0,  1,  5, 14,  0,  1,  5, 15, 
    0,  1,  6, 10,  0,  1,  8, 12,  0,  1,  9, 13,  0,  1, 10, 15,  0,  2,  3,  4,  0,  2,  3,  5,  0,  2,  3,  6,  0,  2,  3,  7,  0,  2,  4,  5,  0,  2,  5,  6, 
    0,  2,  6,  7,  0,  4,  5,  7,  0,  4,  5, 11,  0,  4,  5, 12,  0,  4,  5, 13,  0,  4,  5, 14,  0,  4,  5, 15,  0,  4,  6,  7,  0,  4,  9, 10,  0,  4,  9, 12, 
    0,  4, 10, 15,  0,  4, 12, 13,  0,  5,  6,  9,  0,  5,  6, 15,  0,  5,  8,  9,  0,  5,  8, 12,  0,  5,  9, 15,  0,  5, 11, 15,  0,  5, 14, 15,  0,  6,  7, 11, 
    0,  6, 10, 11,  0,  6, 10, 15,  0,  8,  9, 12,  0,  8,  9, 13,  0,  8, 12, 13,  0,  9, 10, 14,  0,  9, 10, 15,  0,  9, 13, 14,  0, 10, 11, 15,  0, 10, 14, 15, 
    1,  2,  4,  6,  1,  2,  4,  8,  1,  2,  5,  7,  1,  2,  5, 10,  1,  2,  5, 12,  1,  2,  5, 13,  1,  2,  6,  9,  1,  2,  6, 14,  1,  2,  6, 15,  1,  2,  7, 11, 
    1,  2,  9, 13,  1,  2, 10, 14,  1,  3,  4,  5,  1,  3,  5,  6,  1,  3,  6,  7,  1,  4,  5,  7,  1,  4,  5, 10,  1,  4,  5, 12,  1,  4,  5, 13,  1,  4,  6,  7, 
    1,  4,  8,  9,  1,  4,  9, 13,  1,  5,  6,  8,  1,  5,  6, 13,  1,  5,  6, 14,  1,  5,  6, 15,  1,  5,  8, 13,  1,  5, 10, 11,  1,  5, 10, 13,  1,  5, 12, 13, 
    1,  5, 13, 14,  1,  6,  7, 10,  1,  6,  9, 10,  1,  6,  9, 13,  1,  8,  9, 12,  1,  8,  9, 13,  1,  9, 10, 13,  1,  9, 10, 14,  1,  9, 12, 13,  1,  9, 13, 14, 
    1, 10, 11, 15,  1, 10, 14, 15,  2,  3,  4,  6,  2,  3,  5,  7,  2,  3,  5,  9,  2,  3,  6,  8,  2,  3,  6, 11,  2,  3,  6, 12,  2,  3,  6, 13,  2,  3,  6, 14, 
    2,  3,  7, 10,  2,  3,  7, 15,  2,  3,  9, 12,  2,  3, 10, 14,  2,  3, 11, 15,  2,  4,  5,  7,  2,  4,  5,  9,  2,  4,  6,  7,  2,  5,  6, 11,  2,  5,  6, 12, 
    2,  5,  6, 13,  2,  5,  6, 14,  2,  5,  9, 10,  2,  5, 10, 14,  2,  6,  7,  9,  2,  6,  7, 14,  2,  6,  7, 15,  2,  6,  8,  9,  2,  6,  9, 14,  2,  6, 11, 14, 
    2,  6, 13, 14,  2,  6, 14, 15,  2,  7, 10, 11,  2,  7, 10, 14,  2,  8,  9, 12,  2,  9, 10, 13,  2,  9, 10, 14,  2,  9, 12, 13,  2, 10, 11, 14,  2, 10, 11, 15, 
    2, 10, 13, 14,  2, 10, 14, 15,  3,  4,  5,  7,  3,  4,  5,  8,  3,  4,  6,  7,  3,  5,  6, 10,  3,  5,  6, 12,  3,  5,  8,  9,  3,  5,  9, 12,  3,  6,  7,  8, 
    3,  6,  7, 12,  3,  6,  7, 13,  3,  6,  7, 14,  3,  6,  7, 15,  3,  6,  8, 12,  3,  6, 10, 11,  3,  6, 10, 12,  3,  6, 11, 15,  3,  6, 12, 13,  3,  7,  9, 10, 
    3,  7,  9, 12,  3,  7, 10, 15,  3,  7, 14, 15,  3,  8,  9, 12,  3,  9, 10, 12,  3,  9, 10, 13,  3,  9, 12, 13,  3, 10, 11, 14,  3, 10, 11, 15,  3, 10, 13, 14, 
    3, 11, 14, 15,  4,  5,  7,  8,  4,  5,  7,  9,  4,  5,  7, 10,  4,  5,  7, 11,  4,  5,  8, 10,  4,  5,  8, 13,  4,  5,  9, 11,  4,  5,  9, 12,  4,  5,  9, 15, 
    4,  5, 10, 14,  4,  6,  7,  8,  4,  6,  7,  9,  4,  6,  7, 10,  4,  6,  7, 11,  4,  6,  8,  9,  4,  6,  9, 10,  4,  6, 10, 11,  4,  8,  9, 11,  4,  8,  9, 15, 
    4,  8, 10, 11,  4,  8, 13, 14,  4,  9, 10, 13,  4,  9, 12, 13,  4, 10, 11, 15,  4, 10, 14, 15,  5,  6,  8, 10,  5,  6,  8, 12,  5,  6,  9, 11,  5,  6,  9, 14, 
    5,  6, 10, 13,  5,  6, 11, 15,  5,  7,  8,  9,  5,  7,  9, 10,  5,  7, 10, 11,  5,  8,  9, 11,  5,  8,  9, 14,  5,  8, 10, 11,  5,  8, 12, 13,  5,  9, 10, 12, 
    5,  9, 14, 15,  5, 10, 11, 14,  5, 10, 13, 14,  6,  7,  8, 10,  6,  7,  9, 11,  6,  7,  9, 13,  6,  7, 10, 12,  6,  7, 10, 15,  6,  7, 11, 14,  6,  8,  9, 11, 
    6,  8,  9, 13,  6,  8, 10, 11,  6,  9, 10, 15,  6,  9, 13, 14,  6, 10, 11, 13,  6, 10, 12, 13,  6, 11, 14, 15,  7,  8,  9, 11,  7,  8,  9, 12,  7,  8, 10, 11, 
    7,  9, 10, 14,  7,  9, 12, 13,  7, 10, 11, 12,  7, 10, 14, 15,  7, 11, 13, 14,  8,  9, 11, 12,  8,  9, 11, 13,  8,  9, 11, 14,  8,  9, 11, 15,  8,  9, 12, 14, 
    8,  9, 13, 15,  8, 10, 11, 12,  8, 10, 11, 13,  8, 10, 11, 14,  8, 10, 11, 15,  8, 10, 12, 13,  8, 10, 13, 14,  8, 10, 14, 15,  8, 12, 13, 15,  8, 12, 14, 15, 
    9, 10, 12, 14,  9, 10, 13, 15,  9, 11, 12, 13,  9, 11, 13, 14,  9, 11, 14, 15,  9, 12, 13, 15,  9, 12, 14, 15, 10, 11, 12, 14, 10, 11, 13, 15, 10, 12, 13, 15, 
    10, 12, 14, 15, 11, 12, 13, 15, 11, 12, 14, 15,  0,  1,  2,  4,  0,  1,  2,  5,  0,  1,  2,  6,  0,  1,  2,  7,  0,  1,  4,  5,  0,  1,  4,  8,  0,  1,  5,  6, 
    0,  1,  5,  9,  0,  1,  5, 10,  0,  1,  6,  7,  0,  1,  6, 11,  0,  4,  5,  6,  0,  4,  5,  8,  0,  4,  5,  9,  0,  4,  5, 10,  0,  4,  8,  9,  0,  4,  8, 13, 
    0,  4,  9, 13,  0,  4,  9, 14,  0,  5,  6,  7,  0,  5,  6, 10,  0,  5,  6, 11,  0,  5,  9, 10,  0,  5,  9, 13,  0,  5,  9, 14,  0,  5, 10, 11,  0,  5, 10, 14, 
    1,  2,  3,  4,  1,  2,  3,  5,  1,  2,  3,  6,  1,  2,  3,  7,  1,  2,  4,  5,  1,  2,  5,  6,  1,  2,  5,  8,  1,  2,  5,  9,  1,  2,  6,  7,  1,  2,  6, 10, 
    1,  2,  6, 11,  1,  4,  5,  6,  1,  4,  5,  8,  1,  4,  5,  9,  1,  4,  8, 12,  1,  5,  6,  7,  1,  5,  6,  9,  1,  5,  6, 10,  1,  5,  6, 11,  1,  5,  8,  9, 
    1,  5,  8, 12,  1,  5,  9, 10,  1,  5,  9, 12,  1,  5,  9, 14,  1,  5, 10, 14,  1,  5, 10, 15,  1,  6,  7, 11,  1,  6, 10, 11,  1,  6, 10, 14,  1,  6, 10, 15, 
    1,  6, 11, 15,  2,  3,  4,  5,  2,  3,  5,  6,  2,  3,  5,  8,  2,  3,  6,  7,  2,  3,  6,  9,  2,  3,  6, 10,  2,  3,  7, 11,  2,  4,  5,  6,  2,  4,  5,  8, 
    2,  5,  6,  7,  2,  5,  6,  8,  2,  5,  6,  9,  2,  5,  6, 10,  2,  5,  8,  9,  2,  5,  8, 12,  2,  5,  9, 12,  2,  5,  9, 13,  2,  6,  7, 10,  2,  6,  7, 11, 
    2,  6,  9, 10,  2,  6,  9, 12,  2,  6,  9, 13,  2,  6, 10, 11,  2,  6, 10, 13,  2,  6, 10, 15,  2,  6, 11, 15,  2,  7, 11, 15,  3,  4,  5,  6,  3,  5,  6,  7, 
    3,  5,  6,  8,  3,  5,  6,  9,  3,  6,  7,  9,  3,  6,  7, 10,  3,  6,  7, 11,  3,  6,  8,  9,  3,  6,  9, 10,  3,  6,  9, 13,  3,  6, 10, 13,  3,  6, 10, 14, 
    3,  7, 10, 11,  3,  7, 10, 13,  3,  7, 10, 14,  3,  7, 11, 14,  4,  5,  6,  8,  4,  5,  6,  9,  4,  5,  6, 10,  4,  5,  6, 11,  4,  5,  8,  9,  4,  5,  8, 12, 
    4,  5,  9, 10,  4,  5,  9, 13,  4,  5,  9, 14,  4,  5, 10, 11,  4,  5, 10, 15,  4,  8,  9, 10,  4,  8,  9, 12,  4,  8,  9, 13,  4,  8,  9, 14,  4,  8, 12, 13, 
    4,  9, 10, 11,  4,  9, 10, 14,  4,  9, 10, 15,  4,  9, 13, 14,  4,  9, 14, 15,  5,  6,  7,  8,  5,  6,  7,  9,  5,  6,  7, 10,  5,  6,  7, 11,  5,  6,  8,  9, 
    5,  6,  9, 10,  5,  6,  9, 12,  5,  6,  9, 13,  5,  6, 10, 11,  5,  6, 10, 14,  5,  6, 10, 15,  5,  8,  9, 10,  5,  8,  9, 12,  5,  8,  9, 13,  5,  9, 10, 11, 
    5,  9, 10, 13,  5,  9, 10, 14,  5,  9, 10, 15,  5,  9, 12, 13,  5,  9, 13, 14,  5, 10, 11, 15,  5, 10, 14, 15,  6,  7,  8,  9,  6,  7,  9, 10,  6,  7,  9, 12, 
    6,  7, 10, 11,  6,  7, 10, 13,  6,  7, 10, 14,  6,  7, 11, 15,  6,  8,  9, 10,  6,  8,  9, 12,  6,  9, 10, 11,  6,  9, 10, 12,  6,  9, 10, 13,  6,  9, 10, 14, 
    6,  9, 12, 13,  6, 10, 11, 14,  6, 10, 11, 15,  6, 10, 13, 14,  6, 10, 14, 15,  7,  8,  9, 10,  7,  9, 10, 11,  7,  9, 10, 12,  7,  9, 10, 13,  7, 10, 11, 13, 
    7, 10, 11, 14,  7, 10, 11, 15,  7, 10, 12, 13,  7, 10, 13, 14,  7, 11, 14, 15,  8,  9, 10, 12,  8,  9, 10, 13,  8,  9, 10, 14,  8,  9, 10, 15,  8,  9, 12, 13, 
    8,  9, 13, 14,  8,  9, 14, 15,  8, 12, 13, 14,  8, 13, 14, 15,  9, 10, 11, 12,  9, 10, 11, 13,  9, 10, 11, 14,  9, 10, 11, 15,  9, 10, 12, 13,  9, 10, 13, 14, 
    9, 10, 14, 15,  9, 12, 13, 14,  9, 13, 14, 15, 10, 11, 12, 13, 10, 11, 13, 14, 10, 11, 14, 15, 10, 12, 13, 14, 10, 13, 14, 15, 11, 12, 13, 14, 11, 13, 14, 15
};

//////////////////////////////////////////////////////////////////////////
////---- MotionDetectTable: Revised by yousf 20160816
#if USE_MOTION_DETECT == 1
// Y = 0:1023; gain=8; A=max(4,0.648*sqrt(max((Y-64),0)*gain)); figure,hold on, plot(Y,A, 'r')
DATA_MFNR_EX RK_U16 MotionDetectTable[MOTION_DETECT_TALBE_LEN] = {
//     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
//     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
//     4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9,10,10,
//     10,10,10,10,10,11,11,11,11,11,11,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,14,14,14,14,14,
//     14,14,14,15,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,
//     17,18,18,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,
//     20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,
//     23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,
//     25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,
//     27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,
//     29,29,29,29,29,29,29,29,29,29,29,29,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,31,
//     31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
//     32,32,32,32,32,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,34,34,34,34,34,34,34,
//     34,34,34,34,34,34,34,34,34,34,34,34,34,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,
//     35,35,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,
//     37,37,37,37,37,37,37,37,37,37,37,37,37,37,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,
//     38,38,38,38,38,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,40,40,40,
//     40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,41,41,41,41,41,41,41,41,41,41,41,
//     41,41,41,41,41,41,41,41,41,41,41,41,41,41,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,
//     42,42,42,42,42,42,42,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,
//     43,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,45,45,45,45,45,
//     45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,46,46,46,46,46,46,46,46,46,46,
//     46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,47,47,47,47,47,47,47,47,47,47,47,47,47,47,
//     47,47,47,47,47,47,47,47,47,47,47,47,47,47,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,
//     48,48,48,48,48,48,48,48,48,48,48,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,
//     49,49,49,49,49,49,49,49,49,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,
//     50,50,50,50,50,50,50,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,
//     51,51,51,51,51,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,
//     52,52,52,52,52,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,
//     53,53,53,53,53,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,
//     54,54,54,54,54,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,
//     55,55,55,55,55,55,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56
    36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
    36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
    36,36,36,36,36,36,40,43,46,49,52,54,57,59,61,63,65,68,69,71,73,75,77,79,80,82,84,85,87,88,90,91,
    93,94,96,97,98,100,101,103,104,105,106,108,109,110,111,113,114,115,116,117,118,120,121,122,123,124,125,126,127,128,129,130,
    131,132,134,135,136,137,138,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,152,153,154,155,156,157,158,159,159,160,
    161,162,163,164,164,165,166,167,168,169,169,170,171,172,173,173,174,175,176,176,177,178,179,179,180,181,182,182,183,184,185,185,
    186,187,188,188,189,190,190,191,192,193,193,194,195,195,196,197,197,198,199,199,200,201,202,202,203,204,204,205,206,206,207,207,
    208,209,209,210,211,211,212,213,213,214,215,215,216,216,217,218,218,219,220,220,221,221,222,223,223,224,224,225,226,226,227,227,
    228,229,229,230,230,231,232,232,233,233,234,235,235,236,236,237,237,238,239,239,240,240,241,241,242,242,243,244,244,245,245,246,
    246,247,247,248,249,249,250,250,251,251,252,252,253,253,254,255,255,256,256,257,257,258,258,259,259,260,260,261,261,262,262,263,
    263,264,264,265,265,266,267,267,268,268,269,269,270,270,271,271,272,272,273,273,274,274,275,275,276,276,277,277,277,278,278,279,
    279,280,280,281,281,282,282,283,283,284,284,285,285,286,286,287,287,288,288,289,289,289,290,290,291,291,292,292,293,293,294,294,
    295,295,295,296,296,297,297,298,298,299,299,300,300,301,301,301,302,302,303,303,304,304,305,305,305,306,306,307,307,308,308,309,
    309,309,310,310,311,311,312,312,312,313,313,314,314,315,315,316,316,316,317,317,318,318,319,319,319,320,320,321,321,321,322,322,
    323,323,324,324,324,325,325,326,326,327,327,327,328,328,329,329,329,330,330,331,331,331,332,332,333,333,334,334,334,335,335,336,
    336,336,337,337,338,338,338,339,339,340,340,340,341,341,342,342,342,343,343,344,344,344,345,345,346,346,346,347,347,347,348,348,
    349,349,349,350,350,351,351,351,352,352,353,353,353,354,354,354,355,355,356,356,356,357,357,357,358,358,359,359,359,360,360,361,
    361,361,362,362,362,363,363,364,364,364,365,365,365,366,366,366,367,367,368,368,368,369,369,369,370,370,371,371,371,372,372,372,
    373,373,373,374,374,375,375,375,376,376,376,377,377,377,378,378,379,379,379,380,380,380,381,381,381,382,382,382,383,383,384,384,
    384,385,385,385,386,386,386,387,387,387,388,388,388,389,389,390,390,390,391,391,391,392,392,392,393,393,393,394,394,394,395,395,
    395,396,396,396,397,397,397,398,398,398,399,399,399,400,400,401,401,401,402,402,402,403,403,403,404,404,404,405,405,405,406,406,
    406,407,407,407,408,408,408,409,409,409,410,410,410,411,411,411,412,412,412,413,413,413,414,414,414,415,415,415,415,416,416,416,
    417,417,417,418,418,418,419,419,419,420,420,420,421,421,421,422,422,422,423,423,423,424,424,424,425,425,425,426,426,426,426,427,
    427,427,428,428,428,429,429,429,430,430,430,431,431,431,432,432,432,432,433,433,433,434,434,434,435,435,435,436,436,436,437,437,
    437,437,438,438,438,439,439,439,440,440,440,441,441,441,442,442,442,442,443,443,443,444,444,444,445,445,445,445,446,446,446,447,
    447,447,448,448,448,449,449,449,449,450,450,450,451,451,451,452,452,452,452,453,453,453,454,454,454,455,455,455,455,456,456,456,
    457,457,457,458,458,458,458,459,459,459,460,460,460,460,461,461,461,462,462,462,463,463,463,463,464,464,464,465,465,465,465,466,
    466,466,467,467,467,468,468,468,468,469,469,469,470,470,470,470,471,471,471,472,472,472,472,473,473,473,474,474,474,474,475,475,
    475,476,476,476,476,477,477,477,478,478,478,478,479,479,479,480,480,480,480,481,481,481,482,482,482,482,483,483,483,484,484,484,
    484,485,485,485,485,486,486,486,487,487,487,487,488,488,488,489,489,489,489,490,490,490,490,491,491,491,492,492,492,492,493,493,
    493,494,494,494,494,495,495,495,495,496,496,496,497,497,497,497,498,498,498,498,499,499,499,500,500,500,500,501,501,501,501,502,
    502,502,503,503,503,503,504,504,504,504,505,505,505,506,506,506,506,507,507,507,507,508,508,508,508,509,509,509,510,510,510,510
};
#endif


//////////////////////////////////////////////////////////////////////////
////-------- Functions Definition
//
CODE_MFNR_EX
int CopyThumbChunkBOUDER(RK_U32 srcAddr, RK_U32 dstAddr, int nWid, int nHgt, int nSrcStride, int nDstStride)
{
    ////
    int     ret = 0; // return value

    RK_U8*     p_src = (RK_U8*)srcAddr; // temp pointer
    RK_U8*     p_dst = (RK_U8*)dstAddr; // temp pointer
    for (int i=0; i < nHgt; i++)
    {
        memcpy(p_dst, p_src, nWid*sizeof(RK_U16));
        p_src += nSrcStride;
        p_dst += nDstStride;
    }

    //
    return ret;
} // CopyBlockData()

/************************************************************************/
// Func: classMFNR::RKDMA_ReadThumb16bit2DSP()
// Desc: transfer_mode = 0 // RDMA_DIRECTION
//   In: srcAddr            - src pointer value
//       wid                - block data width
//       hgt                - block data height
//       srcStride          - src data Stride
//       dstStride          - dst data Stride
//       col                - block data col
//  Out: dstAddr            - dst pointer value
// 
// Date: Revised by yousf 20160820
// 
/*************************************************************************/
CODE_MFNR_EX
int classMFNR::RKDMA_ReadThumb16bit2DSP(U32 srcAddr, U32 dstAddr, U16 wid, U16 hgt, U16 srcStride, U16 dstStride, U16 col)
{
    //
    int     ret = 0; // return value
    int pos;

    // DMA Info Struct
    rdma_info_t     rdmaInfo;

    rdmaInfo.src_addr       = srcAddr;              /* source pic addr */
    rdmaInfo.dst_addr       = dstAddr;              /* destin pic addr */
    rdmaInfo.width          = wid * sizeof(U16);    /* pixel num */
    rdmaInfo.height         = hgt;				    /* row num */
    rdmaInfo.src_stride     = srcStride; 		    /* unit is byte */
    rdmaInfo.dst_stride     = dstStride;			/* unit is byte */
    rdmaInfo.transfer_mode  = RDMA_DIRECTION;       /* enum rdma_transfer_mode */
     rdmaInfo.shift_num      = 0;			        /* 10bit -> 16bit every pixel left shift num / 16bit -> 10bit every pixel right shift num */
     rdmaInfo.bit_offset     = 0;                 /* 10bit -> 16bit src line first pixel bits offset / 16bit -> 10bit dst line first pixel bits offset */
//     rdmaInfo.dsp_sel        = ;
     rdmaInfo.dir            = DIR_EXT_INT;
//     rdmaInfo.res[3]         = ;


#if DEBUG_DMA_SW_HW == 0 // 0-Use CEVA_CHIP_CODE   1-Use flag_UseHwDMA

     pos = rdma_transf(&rdmaInfo); // DMA
#ifdef CEVA_CHIP_CODE
	rdma_sync(pos);
#endif

#else// 0-Use CEVA_CHIP_CODE   1-Use flag_UseHwDMA

	pos = rdma_transf(&rdmaInfo, mUseHwDMA); // DMA
	if (mUseHwDMA == 1)
	{
		rdma_sync(pos);
	}//*/

#endif

    //
    return ret;

} // classMFNR::RKDMA_ReadThumb16bit2DSP()


/************************************************************************/
// Func: classMFNR::RKDMA_ReadRaw10bit2DSP()
// Desc: transfer_mode = 1 // RDMA_10BIT_2_16BIT
//   In: srcAddr            - src pointer value
//       wid                - block data width
//       hgt                - block data height
//       srcStride          - src data Stride
//       dstStride          - dst data Stride
//       col                - block data col
//  Out: dstAddr            - dst pointer value
// 
// Date: Revised by yousf 20160820
// 
/*************************************************************************/
CODE_MFNR_EX
int classMFNR::RKDMA_ReadRaw10bit2DSP(U32 srcAddr, U32 dstAddr, U16 wid, U16 hgt, U16 srcStride, U16 dstStride, U16 col)
{
    //
    int     ret = 0; // return value
    int pos;

    //      Bytes: 8 2+6 4+4 6+2 8
    //     Pixels: 8+2 6+4 4+6 2+8
    // bit_offset: 0   2   4   6
    int bit_offset = col % 4 * 2;

    // DMA Info Struct
    rdma_info_t     rdmaInfo;

    rdmaInfo.src_addr       = srcAddr;              /* source pic addr */
    rdmaInfo.dst_addr       = dstAddr;              /* destin pic addr */
    rdmaInfo.width          = wid;                  /* pixel num */
    rdmaInfo.height         = hgt;				    /* row num */
    rdmaInfo.src_stride     = srcStride; 		    /* unit is byte */
    rdmaInfo.dst_stride     = dstStride;			/* unit is byte */
    rdmaInfo.transfer_mode  = RDMA_10BIT_2_16BIT;   /* enum rdma_transfer_mode */
    rdmaInfo.shift_num      = 0;			        /* 10bit -> 16bit every pixel left shift num / 16bit -> 10bit every pixel right shift num */
    rdmaInfo.bit_offset     = bit_offset;           /* 10bit -> 16bit src line first pixel bits offset / 16bit -> 10bit dst line first pixel bits offset */
//     rdmaInfo.dsp_sel        = ; 
     rdmaInfo.dir            = DIR_EXT_INT;
//     rdmaInfo.res[3]         = ;


#if DEBUG_DMA_SW_HW == 0 // 0-Use CEVA_CHIP_CODE   1-Use flag_UseHwDMA

     pos = rdma_transf(&rdmaInfo); // DMA
#ifdef CEVA_CHIP_CODE
	rdma_sync(pos);
#endif

#else// 0-Use CEVA_CHIP_CODE   1-Use flag_UseHwDMA

	pos = rdma_transf(&rdmaInfo, mUseHwDMA); // DMA
	if (mUseHwDMA == 1)
	{
		rdma_sync(pos);
	}//*/

#endif
    //
    return ret;

} // classMFNR::RKDMA_ReadRaw10bit2DSP()


/************************************************************************/
// Func: classMFNR::RKDMA_WriteRaw16bit2DDR()
// Desc: transfer_mode = 2 // RDMA_16BIT_2_10BIT
//   In: srcAddr            - src pointer value
//       wid                - block data width
//       hgt                - block data height
//       srcStride          - src data Stride
//       dstStride          - dst data Stride
//       col                - block data col
//  Out: dstAddr            - dst pointer value
// 
// Date: Revised by yousf 20160820
// 
/*************************************************************************/
CODE_MFNR_EX
int classMFNR::RKDMA_WriteRaw16bit2DDR(U32 srcAddr, U32 dstAddr, U16 wid, U16 hgt, U16 srcStride, U16 dstStride, U16 col)
{
    //
    int     ret = 0; // return value
    int pos;

    //      Bytes: 8 2+6 4+4 6+2 8
    //     Pixels: 8+2 6+4 4+6 2+8
    // bit_offset: 0   2   4   6
    int bit_offset = col % 4 * 2;

    // DMA Info Struct
    rdma_info_t     rdmaInfo;

    rdmaInfo.src_addr       = srcAddr;              /* source pic addr */
    rdmaInfo.dst_addr       = dstAddr;              /* destin pic addr */
    rdmaInfo.width          = wid;                  /* pixel num */
    rdmaInfo.height         = hgt;				    /* row num */
    rdmaInfo.src_stride     = srcStride; 		    /* unit is byte */
    rdmaInfo.dst_stride     = dstStride;			/* unit is byte */
    rdmaInfo.transfer_mode  = RDMA_16BIT_2_10BIT;   /* enum rdma_transfer_mode */
    rdmaInfo.shift_num      = 0;			        /* 10bit -> 16bit every pixel left shift num / 16bit -> 10bit every pixel right shift num */
    rdmaInfo.bit_offset     = bit_offset;           /* 10bit -> 16bit src line first pixel bits offset / 16bit -> 10bit dst line first pixel bits offset */
//     rdmaInfo.dsp_sel        = ; 
     rdmaInfo.dir            = DIR_INT_EXT;
//     rdmaInfo.res[3]         = ;


#if DEBUG_DMA_SW_HW == 0 // 0-Use CEVA_CHIP_CODE   1-Use flag_UseHwDMA

     pos = rdma_transf(&rdmaInfo); // DMA
#ifdef CEVA_CHIP_CODE
	rdma_sync(pos);
#endif

#else// 0-Use CEVA_CHIP_CODE   1-Use flag_UseHwDMA

	pos = rdma_transf(&rdmaInfo, mUseHwDMA); // DMA
	if (mUseHwDMA == 1)
	{
		rdma_sync(pos);
	}//*/

#endif

    //
    return ret;

} // classMFNR::RKDMA_WriteRaw16bit2DDR()


/************************************************************************/
// Func: classMFNR::MFNR_Init()
// Desc: MFNR Init
//   In: pInputParams   - [in] InputParams pointer
//       pCtrlParams    - [in] ControlParams pointer
//  Out: 
// 
// Date: Revised by yousf 20160818
// 
/*************************************************************************/
CODE_MFNR_EX
int classMFNR::MFNR_Init(RK_InputParams* pInParams, RK_ControlParams* pCtrlParams)
{
    //
    int     ret = 0; // return value
#if MY_DEBUG_PRINTF == 1
    printf("classMFNR::MFNR_Init()\n");
#endif
    // RawSrcs
    mRawWid         = pInParams->nRawWid;		            // Raw data width
    mRawHgt         = pInParams->nRawHgt;			        // Raw data height
    mRawFileNum     = pInParams->nRawFileNum;		        // number of Raw data files
    //mRawStride      = ALIGN_4BYTE_WIDTH(mRawWid, RAW_BIT_COUNT);   // Raw10bit data Stride (Bytes, 4ByteAlign) in DDR
    mRawStride      = ALIGN_4PIXEL_WIDTH(mRawWid)*5/4;      // Raw10bit data Stride (4PixelAlign) in DDR
    mRawDataSize     = mRawHgt * mRawStride;                // Raw10bit data Size (Bytes)
    for (int k=0; k < mRawFileNum; k++)                     // Thumb Srcs data pointers
    {
        pRawSrcs[k]   = (RK_U16*)pInParams->pRawSrcs[k];
    }

    // Scaler
    mScaleRaw2Raw   = SCALER_FACTOR_R2R;                    // scale factor for Raw to Raw (for Preview)
    mScaleRaw2Luma  = SCALER_FACTOR_R2L;                    // scale factor for Raw to Luma
    mScaleRaw2Thumb = SCALER_FACTOR_R2T;                    // scale factor for Raw to Thumbnail

    // ThumbSrcs
    mThumbWid       = mRawWid / mScaleRaw2Thumb;	        // Thumb data width  (floor)
    mThumbHgt       = mRawHgt / mScaleRaw2Thumb;	        // Thumb data height (floor)
    mThumbStride    = ALIGN_4BYTE_WIDTH(mThumbWid,THUMB_BIT_COUNT);// Thumb data Stride (Bytes, 4ByteAlign)
    mThumbDataSize  = mThumbHgt * mThumbStride;             // Thumb data Size (Bytes)
    for (int k=0; k < mRawFileNum; k++)                     // Thumb Srcs data pointers
    {
        pThumbSrcs[k] = (RK_U16*)pInParams->pThumbSrcs[k];
    }


    // ISP Gain
    mIspGain = pInParams->pRawInfo->fIspGain;
    mBlackLevel[0] = pInParams->pRawInfo->nBlackLevel[0];
    mBlackLevel[1] = pInParams->pRawInfo->nBlackLevel[1];
    mBlackLevel[2] = pInParams->pRawInfo->nBlackLevel[2];
    mBlackLevel[3] = pInParams->pRawInfo->nBlackLevel[3];


    mUseHwDMA = pCtrlParams->useHwDMA;

    //////////////////////////////////////////////////////////////////////////
    // DSP Memory
    mDspMem_UsedCount = 0;  // Method-2: use MemoryArray, DSP Memory Array Used Count


    //////////////////////////////////////////////////////////////////////////
    
    //// BaseFrame Feature Detect
    mThumbFeatWinSize   = DIV_FIXED_WIN_SIZE;               // Thumb Feature Win Size
    mThumbDivSegCol     = mThumbWid / mThumbFeatWinSize;    // number of Seg Col
    mThumbDivSegRow     = mThumbHgt / mThumbFeatWinSize;    // number of Seg Row
    mBasePicNum         = BASE_PIC_NUM;                     // Base Picture Num
    mMaxNumFeature      = mThumbDivSegCol * mThumbDivSegRow;// Max Num of Feature

    //
    return ret;

} // classMFNR::MFNR_Init()


/************************************************************************/
// Func: classMFNR::Register()
// Desc: Process Module: Register Interface 
//   In: 
//  Out: 
// 
// Date: Revised by yousf 20160824
// 
/*************************************************************************/
CODE_MFNR_EX
int classMFNR::Register(void)
{
    //
    int     ret = 0; // return value
#if MY_DEBUG_PRINTF == 1
    printf("classMFNR::Register()\n");
#endif
    //
    RK_U16*     pTmpThumbBase = NULL;
    RK_U16*     pTmpThumbDsp  = NULL;
    RK_U16*     pTmpThumbRef  = NULL;
    RK_U16*     pTmpRawBase   = NULL;
    RK_U16*     pTmpRawRef    = NULL;
    int         nThumbChunkStride;
    int         radius;         // search radius
    int         nChunkSize;     // size
    int         chunkIdx;       // odd-even
    int         chunkIdx_base;  // odd-even
    int         chunkIdx_ref;   // odd-even
    RK_U16*     pTmpDspSrc    = NULL;
    RK_U16*     pTmpDspDst    = NULL;

    //////////////////////////////////////////////////////////////////////////
    ////-------- Step 1 Feature Detect
    //==== DSP Malloc: pFeaturePoints & pFeatureValues addr in DSP
    // pFeaturePoints
    nChunkSize         = sizeof(RK_U16) * mMaxNumFeature;
    pFeaturePoints[0]  = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    pFeaturePoints[1]  = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pFeaturePoints !\n");
#endif
        return ret;
    }
    // pFeatureValues
    nChunkSize         = sizeof(RK_U16) * mMaxNumFeature;
    pFeatureValues     = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pFeatureValues !\n");
#endif
        return ret;
    }

    //==== DSP Memory Reuse Operation
    mDspMem_ResetPos = mDspMem_UsedCount; // Mark Position

    //==== DSP Malloc: pThumbDspChunk addr in DSP
    // pThumbDspChunks
    nChunkSize         = sizeof(RK_U16) * (mThumbWid + 2) * (NUM_LINE_DDR2DSP_THUMB + 2);
    pThumbDspChunks[0] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    pThumbDspChunks[1] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pThumbDspChunks !\n");
#endif
        return ret;
    }
    // pThumbFilterDspChunk
    nChunkSize           = sizeof(RK_U16) * (mThumbWid + 2) * (NUM_LINE_DDR2DSP_THUMB + 2);
    pThumbFilterDspChunk = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount    += nChunkSize; // current used count
	memset( pThumbFilterDspChunk, 0, nChunkSize );
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pThumbFilterDspChunk !\n");
#endif
        return ret;
    }
	mDspMem_UsedCount  = ALIGN_SET(mDspMem_UsedCount, 64);
    // pWdrWeightMat: 9x256*4B
    nChunkSize         = sizeof(RK_U32)* 9 * 256;
    pWdrWeightMat      = (RK_U32*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count

    pWdrWeightMat1    = (RK_U32*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += sizeof(RK_U32)* 16 * 256;; // current used count


#if 1                                                       
	// add by zxy for init the full size weigth and count statitics.            
	memset( pWdrWeightMat, 0, nChunkSize );                                     
	memset( pWdrThumbWgtTable, 0, nChunkSize>>1/*sizeof( RK_U16 ) * 9 * 256*/ );

	memset( pWdrWeightMat1, 0, nChunkSize );                                     
	memset( pWdrThumbWgtTable1, 0, nChunkSize>>1/*sizeof( RK_U16 ) * 9 * 256*/ );
	
#endif                                                                       

	
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrWeightMat !\n");
#endif
        return ret;
    }



    //---- DMA: Thumb(DDR16bit->DSP16bit)
    pTmpThumbBase = pThumbSrcs[mBasePicNum]; // stride = mThumbStride // addr in DDR
    chunkIdx      = 0; // odd-even
    pTmpThumbDsp  = pThumbDspChunks[chunkIdx] + (mThumbWid + 2) + 1;
    //memset(pThumbDspChunks[chunkIdx], 0, 2*522*34);
    nThumbChunkStride = sizeof(RK_U16) * (mThumbWid + 2);
    RKDMA_ReadThumb16bit2DSP((U32)pTmpThumbBase, (U32)pTmpThumbDsp, 
        mThumbWid, NUM_LINE_DDR2DSP_THUMB, mThumbStride, nThumbChunkStride, 0);

//    pTmpDspSrc = pThumbDspChunks[chunkIdx] + (mThumbWid + 2);
//    pTmpDspDst = pThumbDspChunks[chunkIdx];
//    CopyBlockData(pTmpDspSrc, pTmpDspDst, mThumbWid + 2, 1, nThumbChunkStride, nThumbChunkStride);

/*
    CopyThumbChunkBOUDER((U32)(pThumbDspChunks[chunkIdx] + (mThumbWid + 2)),
            		     (U32)(pThumbDspChunks[chunkIdx]),
					     mThumbWid + 2, 1, nThumbChunkStride, nThumbChunkStride);
    CopyThumbChunkBOUDER((U32)(pThumbDspChunks[chunkIdx] + 1),
    					 (U32)(pThumbDspChunks[chunkIdx]),
						 1, NUM_LINE_DDR2DSP_THUMB+2, nThumbChunkStride, nThumbChunkStride);
    CopyThumbChunkBOUDER((U32)(pThumbDspChunks[chunkIdx] + (NUM_LINE_DDR2DSP_THUMB+0)*(mThumbWid+2)),
    				     (U32)(pThumbDspChunks[chunkIdx] + (NUM_LINE_DDR2DSP_THUMB+1)*(mThumbWid+2)),
						 mThumbWid + 2, 1, nThumbChunkStride, nThumbChunkStride);
    CopyThumbChunkBOUDER((U32)(pThumbDspChunks[chunkIdx] + mThumbWid),
    					 (U32)(pThumbDspChunks[chunkIdx] + (mThumbWid + 1)),
						 1, NUM_LINE_DDR2DSP_THUMB+2, nThumbChunkStride, nThumbChunkStride);
//*/

//*
    CopyBlockData(pThumbDspChunks[chunkIdx] + (mThumbWid + 2),//(U16*)((U32)pThumbDspChunks[chunkIdx] + (mThumbWid + 2)*2),
                  pThumbDspChunks[chunkIdx],
                  mThumbWid + 2, 1, nThumbChunkStride, nThumbChunkStride);              // Top
    CopyBlockData(pThumbDspChunks[chunkIdx] + 1, 
                  pThumbDspChunks[chunkIdx],
                  1, NUM_LINE_DDR2DSP_THUMB+2, nThumbChunkStride, nThumbChunkStride);   // Left
    CopyBlockData(pThumbDspChunks[chunkIdx] + (NUM_LINE_DDR2DSP_THUMB+0)*(mThumbWid+2),
                  pThumbDspChunks[chunkIdx] + (NUM_LINE_DDR2DSP_THUMB+1)*(mThumbWid+2),
                  mThumbWid + 2, 1, nThumbChunkStride, nThumbChunkStride);              // Down
    CopyBlockData(pThumbDspChunks[chunkIdx] + mThumbWid, 
                  pThumbDspChunks[chunkIdx] + (mThumbWid + 1),
                  1, NUM_LINE_DDR2DSP_THUMB+2, nThumbChunkStride, nThumbChunkStride);   // Right
//*/
    for (int i=0; i < mThumbDivSegRow; i++)
    {
        //---- ThumbChunk Feature Detect
        FeatureDetect(pThumbDspChunks[chunkIdx], mThumbWid+2, NUM_LINE_DDR2DSP_THUMB+2, mThumbStride+4, i, mThumbDivSegCol, pFeaturePoints, pFeatureValues);

		GetWdrWeightTable(	pThumbDspChunks[chunkIdx],  
							mThumbWid+2,                          
							NUM_LINE_DDR2DSP_THUMB+2,             
							mThumbWid+2,                       
							i,                                    
							pThumbFilterDspChunk,                 
							pWdrWeightMat,                        
							pWdrThumbWgtTable,                    
						#if 1//WDR_THUMB_TABLE_TR
							pWdrWeightMat1,        // <<! [in]  
							pWdrThumbWgtTable1,
						#endif	
							((mRawWid+128)>>8) + 1,					      
    			    		((mRawHgt+128)>>8) + 1            
							);                                    

        // Next Chunk
        if (i < mThumbDivSegRow - 1)
        {
            //---- DMA: Thumb(DDR16bit->DSP16bit)
            pTmpThumbBase += mThumbStride/sizeof(RK_U16)*NUM_LINE_DDR2DSP_THUMB; // addr in DDR
            chunkIdx       = (chunkIdx + 1) & 0x1; // odd-even
            pTmpThumbDsp   = pThumbDspChunks[chunkIdx] + (mThumbWid + 2) + 1;
            RKDMA_ReadThumb16bit2DSP((U32)pTmpThumbBase, (U32)pTmpThumbDsp, 
                mThumbWid, NUM_LINE_DDR2DSP_THUMB, mThumbStride, mThumbStride+4, 0);
			CopyBlockData(pThumbDspChunks[chunkIdx] + (mThumbWid + 2), 
				pThumbDspChunks[chunkIdx],
				mThumbWid + 2, 1, nThumbChunkStride, nThumbChunkStride);              // Top
			CopyBlockData(pThumbDspChunks[chunkIdx] + 1, 
				pThumbDspChunks[chunkIdx],
				1, NUM_LINE_DDR2DSP_THUMB+2, nThumbChunkStride, nThumbChunkStride);   // Left
			CopyBlockData(pThumbDspChunks[chunkIdx] + (NUM_LINE_DDR2DSP_THUMB+0)*(mThumbWid+2), 
				pThumbDspChunks[chunkIdx] + (NUM_LINE_DDR2DSP_THUMB+1)*(mThumbWid+2),
				mThumbWid + 2, 1, nThumbChunkStride, nThumbChunkStride);              // Down
			CopyBlockData(pThumbDspChunks[chunkIdx] + mThumbWid, 
				pThumbDspChunks[chunkIdx] + (mThumbWid + 1),
				1, NUM_LINE_DDR2DSP_THUMB+2, nThumbChunkStride, nThumbChunkStride);   // Right
        }
    }

  
#if 1//ndef CEVA_CHIP_CODE_BAYERWDR

	HistFilter( pWdrThumbWgtTable, pWdrWeightMat, ((mRawHgt+128)>>8) + 1, ((mRawWid+128)>>8) + 1  );     
	//normalize                                                                                          
	normalizeWeight( pWdrThumbWgtTable, pWdrWeightMat, ((mRawHgt+128)>>8) + 1, ((mRawWid+128)>>8) + 1 ); 
	//writeFile(pWdrThumbWgtTable, 9*256, "weightData_block.dat");


	HistFilterTranspose( pWdrThumbWgtTable1, pWdrWeightMat1, ((mRawHgt+128)>>8) + 1, ((mRawWid+128)>>8) + 1  );     
	//normalize                                                                                          
	normalizeWeightTranspose( pWdrThumbWgtTable1, pWdrWeightMat1, ((mRawHgt+128)>>8) + 1, ((mRawWid+128)>>8) + 1 );

#else

	//hist filter
	countFilter_Vec( pWdrThumbWgtTable, ( mRawHgt + 128 ) / 256 + 1, ( mRawWid + 128 ) / 256 + 1, 256 );
	weightFilter_Vec( pWdrWeightMat, ( mRawHgt + 128 ) / 256 + 1, ( mRawWid + 128 ) / 256 + 1, 256 );
	normalizeWeight_Vec( pWdrThumbWgtTable, pWdrWeightMat, ( mRawHgt + 128 ) / 256 + 1, ( mRawWid + 128 ) / 256 + 1, 256 );
	//writeFile(pWdrThumbWgtTable, 9*256, "weightData_block.dat");

#endif

#if WDR_WEIGHT_TRANSPOSE// set weight output is 256x16(9 valid) matrix.
	ushort16 v0;
    RK_U16 vReg[16] = {0};
	RK_U16 *pWeightTran = pWdrThumbWgtTable + 9*256;
	RK_U16 *pData 		= pWdrThumbWgtTable1;
	for ( int l = 0 ; l < 256 ; l++ )
	{

		vReg[0] = *(pWdrThumbWgtTable + 0*256 + l); 
		vReg[1] = *(pWdrThumbWgtTable + 1*256 + l);
		vReg[2] = *(pWdrThumbWgtTable + 2*256 + l);
		vReg[3] = *(pWdrThumbWgtTable + 3*256 + l);
		vReg[4] = *(pWdrThumbWgtTable + 4*256 + l);
		vReg[5] = *(pWdrThumbWgtTable + 5*256 + l);
		vReg[6] = *(pWdrThumbWgtTable + 6*256 + l);
		vReg[7] = *(pWdrThumbWgtTable + 7*256 + l);
		vReg[8] = *(pWdrThumbWgtTable + 8*256 + l);		
		v0 = *(ushort16*)vReg;
		
      	vst(v0,	(ushort16*)(pWeightTran+l*16), 0xffff);
		// compare the result
		for ( int rIdx = 0 ; rIdx < 9 ; rIdx++ )
		{
		    ;//assert(vReg[rIdx] == *(pData+rIdx));
		}
		pData += 256;
	}
	
	

#endif
                                                                                            
    //////////////////////////////////////////////////////////////////////////
    ////-------- Step 2 Feature Filter
    FeatureFilter(pFeaturePoints, pFeatureValues, mMaxNumFeature, mThumbWid, mThumbHgt, mNumValidFeature);
    

    //////////////////////////////////////////////////////////////////////////
    ////-------- Step 3 Thumb Coarse Matching
    mDspMem_UsedCount = mDspMem_ResetPos; // Mark Position
    radius = COARSE_MATCH_RADIUS;  // ceil(MAX_OFFSET * 1.0 / SCALER_FACTOR_R2T);     // search radius
    //==== DSP Malloc: pMatchPointYs & pMatchPointXs addr in DSP
    nChunkSize = sizeof(RK_U16) * mNumValidFeature;
    for (int k=0; k < mRawFileNum; k++)
    {
        // pMatchPointsY
        pMatchPointsY[k]   = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
        mDspMem_UsedCount += nChunkSize; // current used count
        if (mDspMem_UsedCount > DSP_MEM_SIZE)
        {
#if MY_DEBUG_PRINTF == 1
            printf("Failed to Allocate pMatchPointsY !\n");
#endif
            return ret;
        }
        // pMatchPointsX
        pMatchPointsX[k]   = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
        mDspMem_UsedCount += nChunkSize; // current used count
        if (mDspMem_UsedCount > DSP_MEM_SIZE)
        {
#if MY_DEBUG_PRINTF == 1
            printf("Failed to Allocate pMatchPointsX !\n");
#endif
            return ret;
        }
    }

    //==== DSP Memory Reuse Operation
    mDspMem_ResetPos = mDspMem_UsedCount; // Mark Position

    //==== DSP Malloc: pThumbBaseBlkDspChunks & pThumbRefBlkDspChunks addr in DSP
    // pThumbBaseBlkDspChunks
    nChunkSize = sizeof(RK_U16) * COARSE_MATCH_WIN_SIZE * COARSE_MATCH_WIN_SIZE;
    pThumbBaseBlkDspChunks[0] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount        += nChunkSize; // current used count
    pThumbBaseBlkDspChunks[1] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount        += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pThumbBaseBlkDspChunks !\n");
#endif
        return ret;
    }
    // pThumbRefBlkDspChunks
    nChunkSize = sizeof(RK_U16) * (COARSE_MATCH_WIN_SIZE + 2*radius) * (COARSE_MATCH_WIN_SIZE + 2*radius);
    pThumbRefBlkDspChunks[0] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount       += nChunkSize; // current used count
    pThumbRefBlkDspChunks[1] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount       += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pThumbRefBlkDspChunks !\n");
#endif
        return ret;
    }

    //---- Features Coarse Matching
    RK_U16      blkRow_div16, blkCol_div16;
    RK_U16      nBaseBlkRow, nBaseBlkCol, nBaseBlkHgt, nBaseBlkWid, nBaseBlkStride;
    RK_U16      nRefBlkRow,  nRefBlkCol,  nRefBlkHgt,  nRefBlkWid,  nRefBlkStride;
    RK_U16      nMatchRow, nMatchCol, nMatchCost;
    //---- DMA: ThumbBase(DDR16bit->DSP16bit)
    blkRow_div16   = pFeaturePoints[0][0] / COARSE_MATCH_WIN_SIZE; // select 16x16Block in 32x32Block in BaseThumb
    blkCol_div16   = pFeaturePoints[1][0] / COARSE_MATCH_WIN_SIZE; 
    nBaseBlkRow    = COARSE_MATCH_WIN_SIZE * blkRow_div16;// block(row, col) 16x16
    nBaseBlkCol    = COARSE_MATCH_WIN_SIZE * blkCol_div16;
    nBaseBlkHgt    = COARSE_MATCH_WIN_SIZE;
    nBaseBlkWid    = COARSE_MATCH_WIN_SIZE;
    nBaseBlkStride = nBaseBlkWid * sizeof(RK_U16);
    pTmpThumbBase  = pThumbSrcs[mBasePicNum] + nBaseBlkRow * mThumbStride/2 + nBaseBlkCol; // stride = mThumbStride
    chunkIdx_base  = 0; // odd-even
    RKDMA_ReadThumb16bit2DSP((U32)pTmpThumbBase, (U32)pThumbBaseBlkDspChunks[chunkIdx_base], 
        nBaseBlkWid, nBaseBlkHgt, mThumbStride, nBaseBlkStride, nBaseBlkCol);
    for (int n=0; n < mNumValidFeature; n++)
    {
        // MatchPoints[Base#0][Feature#0]
        pMatchPointsY[mBasePicNum][n] = nBaseBlkRow;
        pMatchPointsX[mBasePicNum][n] = nBaseBlkCol;

        //---- DMA: ThumbRef(DDR16bit->DSP16bit)
        nRefBlkRow    = MAX(nBaseBlkRow - radius, 0);// block(row, col) (16+2*radius)x(16+2*radius)
        nRefBlkCol    = MAX(nBaseBlkCol - radius, 0);
        nRefBlkHgt    = MIN(nBaseBlkHgt + 2*radius, mThumbHgt - 1);
        nRefBlkWid    = MIN(nBaseBlkWid + 2*radius, mThumbWid - 1);
        nRefBlkStride = nRefBlkWid * sizeof(RK_U16);
        pTmpThumbRef  = pThumbSrcs[1] + nRefBlkRow * mThumbWid + nRefBlkCol; // stride = mThumbStride
        chunkIdx_ref  = 0; // odd-even
        RKDMA_ReadThumb16bit2DSP((U32)pTmpThumbRef, (U32)pThumbRefBlkDspChunks[chunkIdx_ref], 
            nRefBlkWid, nRefBlkHgt, mThumbStride, nRefBlkStride, nRefBlkCol);

        // Matching Ref#k
        for (int k=0; k < mRawFileNum; k++) // Ref#1-#5
        {
            if (k != mBasePicNum)
            {
                //---- Feature Coarse Matching
                FeatureCoarseMatching(pThumbBaseBlkDspChunks[chunkIdx_base], nBaseBlkHgt, nBaseBlkWid, 
                    pThumbRefBlkDspChunks[chunkIdx_ref], nRefBlkHgt, nRefBlkWid, nMatchRow, nMatchCol, nMatchCost);

                // MatchPoints[Base#0][Feature#k]
                pMatchPointsY[k][n] = nRefBlkRow + nMatchRow;
                pMatchPointsX[k][n] = nRefBlkCol + nMatchCol;

                // Next RefChunk
                if (k < mRawFileNum - 1)
                {
                    //---- DMA: ThumbRef(DDR16bit->DSP16bit)
                    pTmpThumbRef  = pThumbSrcs[k+1] + nRefBlkRow * mThumbStride/2 + nRefBlkCol; // stride = mThumbStride
                    chunkIdx_ref  = (chunkIdx_ref + 1) & 0x1; // odd-even
                    RKDMA_ReadThumb16bit2DSP((U32)pTmpThumbRef, (U32)pThumbRefBlkDspChunks[chunkIdx_ref], 
                        nRefBlkWid, nRefBlkHgt, mThumbStride, nRefBlkStride, nRefBlkCol);
                }
            }
        }
        
        // Next BaseChunk
        if (n < mNumValidFeature - 1)
        {
            //---- DMA: ThumbBase(DDR16bit->DSP16bit)
            blkRow_div16   = pFeaturePoints[0][n+1] / COARSE_MATCH_WIN_SIZE; // select 16x16Block in 32x32Block in BaseThumb
            blkCol_div16   = pFeaturePoints[1][n+1] / COARSE_MATCH_WIN_SIZE; 
            nBaseBlkRow    = COARSE_MATCH_WIN_SIZE * blkRow_div16;// block(row, col) 16x16
            nBaseBlkCol    = COARSE_MATCH_WIN_SIZE * blkCol_div16;
            nBaseBlkHgt    = COARSE_MATCH_WIN_SIZE;
            nBaseBlkWid    = COARSE_MATCH_WIN_SIZE;
            nBaseBlkStride = nBaseBlkWid * sizeof(RK_U16);
            pTmpThumbBase  = pThumbSrcs[mBasePicNum] + nBaseBlkRow * mThumbStride/2 + nBaseBlkCol; // stride = mThumbStride
            chunkIdx_base  = (chunkIdx_base + 1) & 0x1; // odd-even
            RKDMA_ReadThumb16bit2DSP((U32)pTmpThumbBase, (U32)pThumbBaseBlkDspChunks[chunkIdx_base], 
                nBaseBlkWid, nBaseBlkHgt, mThumbStride, nBaseBlkStride, nBaseBlkCol);
        }
    } // for n


    //////////////////////////////////////////////////////////////////////////
    ////-------- Step 4 Luma Fine Matching
    mDspMem_UsedCount = mDspMem_ResetPos; // Mark Position
    radius            = FINE_LUMA_RADIUS * 2;  // ceil(MAX_OFFSET * 1.0 / SCALER_FACTOR_R2T); // search radius
    //==== DSP Malloc: pFeatureIdxsInAgent & pAgentPointsWeight addr in DSP
    // pFeatureIdxsInAgent
    nChunkSize          = sizeof(RK_U8) * mNumValidFeature;
    pFeatureIdxsInAgent = (RK_U8*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount  += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pFeatureIdxsInAgent !\n");
#endif
        return ret;
    }
    // pAgentPointsWeight
    nChunkSize = sizeof(RK_U16) * mNumValidFeature;
    for (int k=0; k < mRawFileNum; k++)
    {
        pAgentPointsWeight[k] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
        mDspMem_UsedCount    += nChunkSize; // current used count
        if (mDspMem_UsedCount > DSP_MEM_SIZE)
        {
#if MY_DEBUG_PRINTF == 1
            printf("Failed to Allocate pAgentPointsWeight[%d] !\n", k);
#endif
            return ret;
        }
    }

    //==== DSP Memory Reuse Operation
    mDspMem_ResetPos = mDspMem_UsedCount; // Mark Position

    //==== DSP Malloc: pRawBaseBlkDspChunks & pLumaBaseBlkDspChunks & pRawRefBlkDspChunks & pLumaRefBlkDspChunks addr in DSP
    // pRawBaseBlkDspChunks
    nChunkSize = sizeof(RK_U16) * FINE_MATCH_WIN_SIZE * FINE_MATCH_WIN_SIZE;
    pRawBaseBlkDspChunks[0] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount      += nChunkSize; // current used count
    pRawBaseBlkDspChunks[1] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount      += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pRawBaseBlkDspChunks !\n");
#endif
        return ret;
    }
    // pLumaBaseBlkDspChunks
    nChunkSize              /= 4;
    pLumaBaseBlkDspChunks[0] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount       += nChunkSize; // current used count
    pLumaBaseBlkDspChunks[1] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount       += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pLumaBaseBlkDspChunks !\n");
#endif
        return ret;
    }
    // pRawRefBlkDspChunks
    nChunkSize = sizeof(RK_U16) * (FINE_MATCH_WIN_SIZE + 2*radius) * (FINE_MATCH_WIN_SIZE + 2*radius + 2*4); // 4PixelAlign
    pRawRefBlkDspChunks[0] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount     += nChunkSize; // current used count
    pRawRefBlkDspChunks[1] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount     += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pRawRefBlkDspChunks !\n");
#endif
        return ret;
    }
    // pLumaRefBlkDspChunks
    nChunkSize             /= 4;
    pLumaRefBlkDspChunks[0] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount      += nChunkSize; // current used count
    pLumaRefBlkDspChunks[1] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount      += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pLumaRefBlkDspChunks !\n");
#endif
        return ret;
    }

    
    //---- Features Fine Matching
    int         scaleUpFactor = SCALER_FACTOR_R2T;// scale up factor
    RK_U16      blkRow_div64, blkCol_div64;
    RK_U16      nRefBlkCol_4p,  nRefBlkWid_4p,  nRefBlkStride_4p; // 4PixelAlign
    int			flagRow, flagCol;				// 0-Left/Up 1-Right/Down
    RK_U16      nStartCol;
    RK_U32      nFeatureValue;
    //---- DMA: RawBase(DDR10bit->DSP16bit)
    blkRow_div64   = pFeaturePoints[0][0] * scaleUpFactor / FINE_MATCH_WIN_SIZE; // select 64x64Block in 128x128Block in BaseRaw
    blkCol_div64   = pFeaturePoints[1][0] * scaleUpFactor / FINE_MATCH_WIN_SIZE; 
    nBaseBlkRow    = FINE_MATCH_WIN_SIZE * blkRow_div64;// block(row, col) 64x64
    nBaseBlkCol    = FINE_MATCH_WIN_SIZE * blkCol_div64;
    nBaseBlkHgt    = FINE_MATCH_WIN_SIZE;
    nBaseBlkWid    = FINE_MATCH_WIN_SIZE;
    nBaseBlkStride = nBaseBlkWid * sizeof(RK_U16); // stride in DSP
    pTmpRawBase    = (RK_U16*)((RK_U8*)pRawSrcs[mBasePicNum] + nBaseBlkRow * mRawStride + nBaseBlkCol*5/4); // stride = mRawStride
    chunkIdx_base  = 0; // odd-even
    RKDMA_ReadRaw10bit2DSP((U32)pTmpRawBase, (U32)pRawBaseBlkDspChunks[chunkIdx_base], 
        nBaseBlkWid, nBaseBlkHgt, mRawStride, nBaseBlkStride, nBaseBlkCol);
    Scaler_Raw2Luma(pRawBaseBlkDspChunks[chunkIdx_base], nBaseBlkWid, nBaseBlkHgt, nBaseBlkWid/2, nBaseBlkHgt/2, 
        pLumaBaseBlkDspChunks[chunkIdx_base]);
    
    //pAgentPointsWeight = pFeatureValues;
    for (int n=0; n < mNumValidFeature; n++)
    {
        
        // which 64x64 in 256x256
        flagRow = 1;
        flagCol = 1;
        if (nBaseBlkRow == pMatchPointsY[mBasePicNum][n] * scaleUpFactor)
        {
            flagRow = 0;	// Up
        }
        else
        {
            flagRow = 1;	// Down
        }
        if (nBaseBlkCol == pMatchPointsX[mBasePicNum][n] * scaleUpFactor)
        {
            flagCol = 0;	// Left
        }
        else
        {
            flagCol = 1;	// Right
        }

        // MatchPoints[Base#0][Feature#0]
        pMatchPointsY[mBasePicNum][n] = nBaseBlkRow;
        pMatchPointsX[mBasePicNum][n] = nBaseBlkCol;

        // pAgentPointsWeight
        pAgentPointsWeight[mBasePicNum][n] = 0;

        // Feature
        nFeatureValue = pFeatureValues[n];

        //---- DMA: RawRef(DDR10bit->DSP16bit) nRefBlkCol_4PA,  nRefBlkWid_4PA,  nRefBlkStride_4PA; // 4PixelAlign
        nRefBlkRow       = MAX(pMatchPointsY[1][n]*scaleUpFactor + flagRow*FINE_MATCH_WIN_SIZE - radius, 0);// block(row, col) (64+2*radius)x(64+2*radius)
        nRefBlkCol       = MAX(pMatchPointsX[1][n]*scaleUpFactor + flagCol*FINE_MATCH_WIN_SIZE - radius, 0);
        nRefBlkHgt       = MIN(nBaseBlkHgt + 2*radius, mRawHgt - 1);
        nRefBlkWid       = MIN(nBaseBlkWid + 2*radius, mRawWid - 1);
        nRefBlkStride    = nRefBlkWid * sizeof(RK_U16); // stride in DSP
        nRefBlkCol_4p    = ALIGN_4PIXEL_START(nRefBlkCol);
        nStartCol        = nRefBlkCol - nRefBlkCol_4p;
        nRefBlkWid_4p    = ALIGN_4PIXEL_WIDTH(nStartCol + nRefBlkWid);
        nRefBlkStride_4p = nRefBlkWid_4p * sizeof(RK_U16); // stride in DSP
        pTmpRawRef       = (RK_U16*)((RK_U8*)pRawSrcs[1] + nRefBlkRow * mRawStride + nRefBlkCol_4p*5/4); // stride = mThumbStride
        chunkIdx_ref     = 0; // odd-even
        RKDMA_ReadRaw10bit2DSP((U32)pTmpRawRef, (U32)pRawRefBlkDspChunks[chunkIdx_ref], 
            nRefBlkWid_4p, nRefBlkHgt, mRawStride, nRefBlkStride_4p, nRefBlkCol_4p);
        Scaler_Raw2Luma(pRawRefBlkDspChunks[chunkIdx_ref], nRefBlkWid_4p, nRefBlkHgt, nRefBlkWid_4p/2, nRefBlkHgt/2, 
            pLumaRefBlkDspChunks[chunkIdx_ref]);

        // Matching Ref#k
        for (int k=1; k < mRawFileNum; k++) // Base#0 Ref#1-#5
        {
            //---- Feature Fine Matching
            FeatureFineMatching(pLumaBaseBlkDspChunks[chunkIdx_base], nBaseBlkHgt/2, nBaseBlkWid/2, 
                pLumaRefBlkDspChunks[chunkIdx_ref], nRefBlkHgt/2, nRefBlkWid_4p/2, 
                nStartCol/2, nRefBlkWid/2, 
                nMatchRow, nMatchCol, nMatchCost);

            // MatchPoints[Base#0][Feature#k]
            pMatchPointsY[k][n] = nRefBlkRow    + nMatchRow * 2;
            pMatchPointsX[k][n] = nRefBlkCol_4p + nMatchCol * 2;

            // pAgentPointsWeight
//            pAgentPointsWeight[k][n] = ROUND_U16( (nFeatureValue << 16) * 1.0 / nMatchCost );
            pAgentPointsWeight[k][n] = ROUND_U16( (nFeatureValue << 16) / nMatchCost );
//			pAgentPointsWeight[k][n] = ( (nFeatureValue << 16) / nMatchCost ) & 0xFFFF;

            // Next RefChunk
            if (k < mRawFileNum - 1)
            {
                //---- DMA: RawRef(DDR10bit->DSP16bit)
                nRefBlkRow       = MAX(pMatchPointsY[k+1][n]*scaleUpFactor + flagRow*FINE_MATCH_WIN_SIZE - radius, 0);// block(row, col) (64+2*radius)x(64+2*radius)
                nRefBlkCol       = MAX(pMatchPointsX[k+1][n]*scaleUpFactor + flagCol*FINE_MATCH_WIN_SIZE - radius, 0);
                nRefBlkHgt       = MIN(nBaseBlkHgt + 2*radius, mRawHgt - 1);
                nRefBlkWid       = MIN(nBaseBlkWid + 2*radius, mRawWid - 1);
                nRefBlkStride    = nRefBlkHgt * sizeof(RK_U16); // stride in DSP
                nRefBlkCol_4p    = ALIGN_4PIXEL_START(nRefBlkCol);
                nStartCol        = nRefBlkCol - nRefBlkCol_4p;
                nRefBlkWid_4p    = ALIGN_4PIXEL_WIDTH(nStartCol + nRefBlkWid);
                nRefBlkStride_4p = nRefBlkWid_4p * sizeof(RK_U16); // stride in DSP
                pTmpRawRef       = (RK_U16*)((RK_U8*)pRawSrcs[k+1] + nRefBlkRow * mRawStride + nRefBlkCol_4p*5/4); // stride = mThumbStride
                chunkIdx_ref     = (chunkIdx_ref + 1) & 0x1; // odd-even
                RKDMA_ReadRaw10bit2DSP((U32)pTmpRawRef, (U32)pRawRefBlkDspChunks[chunkIdx_ref], 
                    nRefBlkWid_4p, nRefBlkHgt, mRawStride, nRefBlkStride_4p, nRefBlkCol_4p);
                Scaler_Raw2Luma(pRawRefBlkDspChunks[chunkIdx_ref], nRefBlkWid_4p, nRefBlkHgt, nRefBlkWid_4p/2, nRefBlkHgt/2, 
                    pLumaRefBlkDspChunks[chunkIdx_ref]);
            }
        }

        // Next BaseChunk
        if (n < mNumValidFeature - 1)
        {
            //---- DMA: ThumbBase(DDR16bit->DSP16bit)
            blkRow_div64   = pFeaturePoints[0][n+1] * scaleUpFactor / FINE_MATCH_WIN_SIZE; // select 64x64Block in 128x128Block in BaseRaw
            blkCol_div64   = pFeaturePoints[1][n+1] * scaleUpFactor / FINE_MATCH_WIN_SIZE; 
            nBaseBlkRow    = FINE_MATCH_WIN_SIZE * blkRow_div64;// block(row, col) 64x64
            nBaseBlkCol    = FINE_MATCH_WIN_SIZE * blkCol_div64;
            nBaseBlkHgt    = FINE_MATCH_WIN_SIZE;
            nBaseBlkWid    = FINE_MATCH_WIN_SIZE;
            nBaseBlkStride = nBaseBlkWid * sizeof(RK_U16);
            pTmpRawBase    = (RK_U16*)((RK_U8*)pRawSrcs[mBasePicNum] + nBaseBlkRow * mRawStride + nBaseBlkCol*5/4); // stride = mRawStride
            chunkIdx_base  = (chunkIdx_base + 1) & 0x1; // odd-even
            RKDMA_ReadRaw10bit2DSP((U32)pTmpRawBase, (U32)pRawBaseBlkDspChunks[chunkIdx_base], 
                nBaseBlkWid, nBaseBlkHgt, mRawStride, nBaseBlkStride, nBaseBlkCol);
            Scaler_Raw2Luma(pRawBaseBlkDspChunks[chunkIdx_base], nBaseBlkWid, nBaseBlkHgt, nBaseBlkWid/2, nBaseBlkHgt/2, 
                pLumaBaseBlkDspChunks[chunkIdx_base]);
        }
    } // for n

   

    //////////////////////////////////////////////////////////////////////////
    ////-------- Step 5 Compute Homography
    mDspMem_UsedCount = mDspMem_ResetPos; // Mark Position
    //==== DSP Malloc: pHomographyMatrix addr in DSP
    // pHomographyMatrix move to the DSP Memory addr#0

    //==== DSP Memory Reuse Operation
    mDspMem_ResetPos = mDspMem_UsedCount; // Mark Position

    //==== DSP Malloc: pRowMvHist & pColMvHist & pMarkMatchFeature & ... addr in DSP
    // pRowMvHist & pColMvHist
#if USE_MV_HIST_FILTRATE == 1
    nChunkSize         = sizeof(RK_U8) * LEN_MV_HIST;
    pRowMvHist         = (RK_U8*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    pColMvHist         = (RK_U8*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pRowMvHist & pColMvHist !\n");
#endif
        return ret;
    }
#endif
    // pMarkMatchFeature
    nChunkSize         = sizeof(RK_U8) * MAX_NUM_MATCH_FEATURE;
    pMarkMatchFeature  = (RK_U8*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pMarkMatchFeature !\n");
#endif
        return ret;
    }
    // pAgentsIn4x4Region_Marks // Agents in 4x4 Region [RegMark4x4] * 16
    nChunkSize               = sizeof(RK_U8) * NUM_DIVIDE_IMAGE * NUM_DIVIDE_IMAGE;
    pAgentsIn4x4Region_Marks = (RK_U8*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount       += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pAgentsIn4x4Region_Marks !\n");
#endif
        return ret;
    }
    // pAgentsIn4x4Region_Wgts // Agents in 4x4 Region [Sharp/SAD] * 16
    nChunkSize              = sizeof(RK_U16) * NUM_DIVIDE_IMAGE * NUM_DIVIDE_IMAGE;
    pAgentsIn4x4Region_Wgts = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount      += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pAgentsIn4x4Region_Wgts !\n");
#endif
        return ret;
    }
    // pAgentsIn4x4Region_PtYs & pAgentsIn4x4Region_PtXs
    nChunkSize = sizeof(RK_U16) * NUM_DIVIDE_IMAGE * NUM_DIVIDE_IMAGE;
    for (int k=0; k < mRawFileNum; k++)
    {
        // Agents in 4x4 Region [Y] * RawFileNum * 16
        pAgentsIn4x4Region_PtYs[k] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
        mDspMem_UsedCount         += nChunkSize; // current used count
        if (mDspMem_UsedCount > DSP_MEM_SIZE)
        {
#if MY_DEBUG_PRINTF == 1
            printf("Failed to Allocate pAgentsIn4x4Region_PtYs !\n");
#endif
            return ret;
        }
        // Agents in 4x4 Region [X] * RawFileNum * 16
        pAgentsIn4x4Region_PtXs[k] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
        mDspMem_UsedCount         += nChunkSize; // current used count
        if (mDspMem_UsedCount > DSP_MEM_SIZE)
        {
#if MY_DEBUG_PRINTF == 1
            printf("Failed to Allocate pAgentsIn4x4Region_PtXs !\n");
#endif
            return ret;
        }
    }
    // pRegion4Points // 4 points in 4 Regions: [x0,y0,x1,y1] * 4Points * 2Byte
    nChunkSize     = sizeof(RK_U16) * 4 * 4;
    pRegion4Points = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pRegion4Points !\n");
#endif
        return ret;
    }
    // pMatrixA // Coefficient Matrix A for A*X = B: 8*8*4Byte
    nChunkSize = sizeof(RK_F32) * 8 * 8;
    pMatrixA   = (RK_F32*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pMatrixA !\n");
#endif
        return ret;
    }
    // pVectorB // Coefficient Vector B for A*X = B: 8*1*4Byte
    nChunkSize = sizeof(RK_F32) * 8 * 1;
    pVectorB   = (RK_F32*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pVectorB !\n");
#endif
        return ret;
    }
    // pVectorX // Coefficient Vector X for A*X = B: 3*3*4Byte
    nChunkSize = sizeof(RK_F32) * 3 * 3;
    pVectorX   = (RK_F32*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pVectorX !\n");
#endif
        return ret;
    }
    // pBasePoint & pRefPoint & pProjPoint
    nChunkSize = sizeof(RK_F32) * 2;
    pBasePoint = (RK_F32*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    pRefPoint  = (RK_F32*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    pProjPoint = (RK_F32*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pBasePoint & pRefPoint & pProjPoint !\n");
#endif
        return ret;
    }



    // init vars
    int         Index4x4;       // Index:0 -- (NUM_DIVIDE_IMAGE * NUM_DIVIDE_IMAGE - 1)
    RK_U16      wgt;            // wgt = sum(Sharp/SAD)
    int         cnt4x4Region;   // count Agents In 4x4 Region

    // MatchingResult in Raw -> Features in Luma 
    int         rowDif;         // feature(row) - rect_top
    int         colDif;         // feature(col) - rect_left
    for (int n=0; n < mNumValidFeature; n++)
    {
        rowDif = pFeaturePoints[0][n] * scaleUpFactor - pMatchPointsY[0][n];
        colDif = pFeaturePoints[1][n] * scaleUpFactor - pMatchPointsX[0][n];
        // MatchingRects -> MatchingPoints
        for (int k=0; k < mRawFileNum; k++)
        {
            pMatchPointsY[k][n] += rowDif;// TopLeft->FeaturePoint
            pMatchPointsX[k][n] += colDif;// TopLeft->FeaturePoint
            pMatchPointsY[k][n] /= 2;// Raw->Luma
            pMatchPointsX[k][n] /= 2;// Raw->Luma
        }
    }

    // Compute RawFileNum-1 Best Homography for BaseFrame--RefFrame(#0 ~ RawFileNum-1)
    int         idxTable;                   // index in Region4IndexTable
    RK_U32      corrCnt = 0;                // Correct Project Count <-- Error Threshold of Valid Homography
#if USE_EARLY_STOP_H == 1 // 1-use Early Stop Compute Homography
    int         goodCnt;                    // Correct Project Count <-- Error Threshold of Good Homography
#endif
    //
#if USE_FLOAT_ERROR == 0 // 0-RK_U16, 1-RK_F32
    //RK_S32      errRow, errCol;             // Project Errors: row error & col error
    RK_U32      errSum_H;                   // Sum Project Errors: sum error of all features
    RK_U32      errMin_H;                   // Min Project Errors: min error of best Homography for BaseFrame--RefFrame#k
#else
    //RK_F32      errRow, errCol;             // Project Errors: row error & col error
    RK_U32      errSum_H;                   // Sum Project Errors: sum error of all features
    RK_U32      errMin_H;                   // Min Project Errors: min error of best Homography for BaseFrame--RefFrame#k
#endif
    //
    RK_F32*     pHomogMat       = NULL;     // temp pointer
    int         numAgents       = NUM_DIVIDE_IMAGE*NUM_DIVIDE_IMAGE;
    for (int k=0; k < mRawFileNum; k++) // mBasePicNum=0
    {
        // Min Project Errors
        //errMin_H  = 0xFFFF; // init (1 << 16) - 1
        errMin_H  = 0xFFFFFFFF; // init (1 << 32) - 1

        // Homography
        pHomogMat = pHomographyMatrix[k]; // Homography: [9*RawFileNum] * 4Byte
        // init eye(3)
        memset(pHomogMat, 0, sizeof(RK_F32)*9);         
        pHomogMat[0] = 1;   // H(0,0)
        pHomogMat[4] = 1;   // H(1,1)
        pHomogMat[8] = 1;   // H(2,2)


        //---- Compute a Best Homography for BaseFrame--RefFrame#k
        if (k != mBasePicNum) // 
        {
            //---- MV Hist Filter
            MvHistFilter(pMatchPointsY, pMatchPointsX, mNumValidFeature,
                pRowMvHist, pColMvHist, mBasePicNum, k, pMarkMatchFeature);


            //-- Agents in 4x4 Region for BaseFrame & RefFrame#k
            cnt4x4Region = 0;
            memset(pAgentsIn4x4Region_Marks, 0, sizeof(RK_U8) * NUM_DIVIDE_IMAGE * NUM_DIVIDE_IMAGE);
            memset(pAgentsIn4x4Region_Wgts,  0, sizeof(RK_U16) * NUM_DIVIDE_IMAGE * NUM_DIVIDE_IMAGE);
            
            for (int n=0; n < mNumValidFeature; n++)
            {
                if (pMarkMatchFeature[n] == 1) // Valid Feature
                {

                    // Feature belong to which Region in 4x4
                    Index4x4 = (pFeaturePoints[0][n] / (mThumbHgt / NUM_DIVIDE_IMAGE)) * NUM_DIVIDE_IMAGE 
                              + pFeaturePoints[1][n] / (mThumbWid / NUM_DIVIDE_IMAGE);

                    // wgt = Sharp / matchSAD <-- BaseFrame & RefFrame#k
                    wgt = pAgentPointsWeight[k][n];

                    // Init or Update AgentsIn4x4Region
                    if (pAgentsIn4x4Region_Marks[Index4x4] == MARK_EXIST_AGENT)    // mark of ExistAgent in 4x4 Region
                    {
                        if (wgt > pAgentsIn4x4Region_Wgts[Index4x4])              // bigger wgt
                        {
                            pAgentsIn4x4Region_Marks[Index4x4] = MARK_EXIST_AGENT; // mark
                            pAgentsIn4x4Region_Wgts[Index4x4]  = wgt;              // Sharp/SAD

                            // MatchingPoints
                            for (int kk=0; kk < mRawFileNum; kk++)
                            {
                                // row col
                                pAgentsIn4x4Region_PtYs[kk][Index4x4] = pMatchPointsY[kk][n];
                                pAgentsIn4x4Region_PtXs[kk][Index4x4] = pMatchPointsX[kk][n];
                            }
                        }
                    }
                    else
                    {
                        // New Agents In 4x4 Region
                        cnt4x4Region++; 
                        pAgentsIn4x4Region_Marks[Index4x4] = MARK_EXIST_AGENT; // mark
                        pAgentsIn4x4Region_Wgts[Index4x4]  = wgt;              // Sharp/SAD

                        // MatchingPoints
                        for (int kk=0; kk < mRawFileNum; kk++)
                        {
                            // row col
                            pAgentsIn4x4Region_PtYs[kk][Index4x4] = pMatchPointsY[kk][n];
                            pAgentsIn4x4Region_PtXs[kk][Index4x4] = pMatchPointsX[kk][n];
                        }
                    } // if
                    
                } // Valid Feature
            } // for n


            //// num Region must be >= 4
            if (cnt4x4Region >= 4)
            {
                // 
                idxTable = 0;   // index in Region4IndexTable: m <= idxTable
                for (int m=0; m < NUM_HOMOGRAPHY; m++)
                {
                    //-- Get Valid 4-Points
                    ret = -1;
                    while (ret && idxTable < NUM_R4IT_CHOICE)
                    {
                        // Get 4 points in 4 Regions
                        ret = GetRegion4Points(pAgentsIn4x4Region_Marks, pAgentsIn4x4Region_PtYs, pAgentsIn4x4Region_PtXs,
                                               Region4IndexTable, idxTable, mBasePicNum, k, pRegion4Points);
                        // Next Item in Region4IndexTable
                        idxTable++; 
                    }
                    //
					if (idxTable >= NUM_R4IT_CHOICE)
					{
						break;
					}

                    //-- Create Coefficient MatrixA & VectorB
                    ret = CreateCoefficient(pRegion4Points, pMatrixA, pVectorB);
                    if (ret)
                    {
#if MY_DEBUG_PRINTF == 1
                        printf("Failed to Create Coefficient MatrixA & VectorB !\n");
#endif
                        //return ret;
                        continue;
                    }

                    //-- Compute a Homography
                    pVectorX[8] = 1;
                    ret = ComputePerspectMatrix(pMatrixA, pVectorB, pVectorX);
                    if (ret)
                    {
#if MY_DEBUG_PRINTF == 1
                        printf("Failed to Compute a Homography !\n");
#endif
                        //return ret;

                        // init eye(3)
                        //memset(pHomogMat, 0, sizeof(RK_F32)*9);
                        //pHomogMat[0] = 1;   // H(0,0)
                        //pHomogMat[4] = 1;   // H(1,1)
                        //pHomogMat[8] = 1;   // H(2,2)
                        memset(pVectorX, 0, sizeof(RK_F32)*9);
						pVectorX[0] = 1;   // H(0,0)
						pVectorX[4] = 1;   // H(1,1)
						pVectorX[8] = 1;   // H(2,2)
                        //break;
                        continue;
                    }

                    //-- Agents' Error
                    ComputeHomographyError(
                        0,                          // type=0(AgentsFeatures)
                        pAgentsIn4x4Region_Marks,   // Agents in 4x4 Region [RegMark4x4] * 16
                        numAgents,                  // =16 =NUM_DIVIDE_IMAGE*NUM_DIVIDE_IMAGE
                        pAgentsIn4x4Region_PtYs,    // Agents in 4x4 Region: [Y] * RawFileNum * 16
                        pAgentsIn4x4Region_PtXs,    // Agents in 4x4 Region: [X] * RawFileNum * 16
                        mBasePicNum,                // Base#0
                        k,                          // Ref#k
                        pVectorX,                   // pVecX * pBasePoint = pProjectPoint
                        pBasePoint,                 // pVecX * pBasePoint = pProjectPoint
                        pProjPoint,                 // pVecX * pBasePoint = pProjectPoint
                        pRefPoint,                  // abs(pRefPoint - pProjPoint)
                        corrCnt);                   // Correct Project Count <-- Error Threshold of Valid Homography
                        
                    //printf("corrCnt=%f\n",corrCnt);
//                     corrCnt = 0;    // Correct Project Count <-- Error Threshold of Valid Homography
// #if USE_EARLY_STOP_H == 1 // 1-use Early Stop Compute Homography
//                     goodCnt = 0;	// Correct Project Count <-- Error Threshold of Good Homography
// #endif
//                     for (int n=0; n < NUM_DIVIDE_IMAGE*NUM_DIVIDE_IMAGE; n++)
//                     {
//                         if (pAgentsIn4x4Region_Marks[n] == MARK_EXIST_AGENT)
//                         {
//                             // Perspective Project: pVecX * pBasePoint = pProjectPoint
//                             pBasePoint[0] = pAgentsIn4x4Region_PtYs[mBasePicNum][n];
//                             pBasePoint[1] = pAgentsIn4x4Region_PtXs[mBasePicNum][n];
//                             pRefPoint[0]  = pAgentsIn4x4Region_PtYs[k][n];
//                             pRefPoint[1]  = pAgentsIn4x4Region_PtXs[k][n];
// 
//                             ret = PerspectProject(pVectorX, pBasePoint, pProjPoint);
//                             if (ret)
//                             {
//                                 printf("Failed to PerspectProject !\n");
//                                 //return ret;
//                                 continue;
//                             }
// 
//                             // Project Errors
// #if USE_FLOAT_ERROR == 0 // 0-RK_U16, 1-RK_F32
//                             errRow = ABS_U16(pRefPoint[0] - pProjPoint[0]);
//                             errCol = ABS_U16(pRefPoint[1] - pProjPoint[1]);   
// #else
//                             errRow = FABS(pRefPoint[0] - pProjPoint[0]);
//                             errCol = FABS(pRefPoint[1] - pProjPoint[1]); 
// #endif
// 
//                             // Error Threshold of Valid Homography
//                             if (errRow <= ERR_TH_VALID_H && errCol <= ERR_TH_VALID_H)
//                             {
//                                 corrCnt++; // Correct Project Count <-- Error Threshold of Valid Homography
//                             }
// 
// #if USE_EARLY_STOP_H == 1 // 1-use Early Stop Compute Homography
//                             // Error Threshold of Good Homography
//                             if (errRow <= ERR_TH_GOOD_H && errCol <= ERR_TH_GOOD_H)
//                             {
//                                 goodCnt++; // Correct Project Count <-- Error Threshold of Good Homography
//                             }
// #endif
// 
//                         }
//                     } // for n

#if USE_EARLY_STOP_H == 1 // 1-use Early Stop Compute Homography
                    if (goodCnt > cnt4x4Region * GOOD_CNT_H_RATIO)// && goodCnt > CRRCNT_TH_VALID_H)
                    {
                        memcpy(pHomogMat, pVectorX, sizeof(RK_F32)*9);
                        break;
                    }
#endif

                    //-- Correct Count Threshold of Valid Homography
                    if (corrCnt > CRRCNT_TH_VALID_H)
                    {

                        ComputeHomographyError(
                            1,                  // type=1(AllFeatures)
                            pMarkMatchFeature,  // AllFeatures' Marks: [Mark] * n
                            mNumValidFeature,   // num of Valid Feature
                            pMatchPointsY,      // Matching Points Y: [Y] * RawFileNum * n
                            pMatchPointsX,      // Matching Points X: [X] * RawFileNum * n
                            mBasePicNum,        // Base #0
                            k,                  // Ref #k
                            pVectorX,           // pVecX * pBasePoint = pProjectPoint
                            pBasePoint,         // pVecX * pBasePoint = pProjectPoint
                            pProjPoint,         // pVecX * pBasePoint = pProjectPoint
                            pRefPoint,          // abs(pRefPoint - pProjPoint)
                            errSum_H);          // Sum Project Errors: sum error of all features


//                         // Compute Homography Error: All Features
//                         errSum_H         = 0;                           // init
//                         for (int n=0; n < mNumValidFeature; n++)
//                         {
//                             if (pMarkMatchFeature[n] == 1) // Valid Feature
//                             {
//                                 // Perspective Project: pVecX * pBasePoint = pProjectPoint
//                                 pBasePoint[0] = pMatchPointsY[mBasePicNum][n];
//                                 pBasePoint[1] = pMatchPointsX[mBasePicNum][n];
//                                 pRefPoint[0]  = pMatchPointsY[k][n];
//                                 pRefPoint[1]  = pMatchPointsX[k][n];
//                                 ret = PerspectProject(pVectorX, pBasePoint, pProjPoint);
//                                 if (ret)
//                                 {
//                                     printf("Failed to PerspectProject !\n");
//                                     //return ret;
//                                     continue;
//                                 }
// 
//                                 // Project Errors: row error & col error
// #if USE_FLOAT_ERROR == 0 // 0-RK_U16, 1-RK_F32
//                                 errRow = ABS_U16(pRefPoint[0] - pProjPoint[0]);
//                                 errCol = ABS_U16(pRefPoint[1] - pProjPoint[1]);
// #else
//                                 errRow = FABS(pRefPoint[0] - pProjPoint[0]);
//                                 errCol = FABS(pRefPoint[1] - pProjPoint[1]); 
// #endif
//                                 errRow = MIN(errRow, MAX_PROJECT_ERROR);
//                                 errCol = MIN(errCol, MAX_PROJECT_ERROR);
// 
//                                 // Sum Project Errors: sum error of all features
//                                 errSum_H += (errRow + errCol); 
//                             }
//                         }

                        // Better Homography
                        if (errSum_H < errMin_H)
                        {
                            // Update H: Min Project Errors & Homography
                            errMin_H = errSum_H;
                            memcpy(pHomogMat, pVectorX, sizeof(RK_F32)*9);
                        }

                    } // if corrCnt
                } // for m
            } // if (cnt4x4Region >= 4)

        } // if (k != mBasePicNum)
    } // for k



    //
    //return ret;
    return 0;

} // classMFNR::Register()


/************************************************************************/
// Func: classMFNR::Register_BypassWrite()
// Desc: Register_BypassRead
//   In: pHomoMats      - [in] Homography: [9*nRawFileNum] * 4Byte
//       nRawFileNum    - [in] RawSrcs data file number
//  Out: fileName       - [out] Output file name
// 
// Date: Revised by yousf 20160822
// 
/*************************************************************************/
CODE_MFNR_EX
int classMFNR::Register_BypassWrite(RK_F32* pHomoMats[], int nRawFileNum)
{
    //
    int     ret = 0; // return value
#ifdef PC_DEBUG
#if MY_DEBUG_PRINTF == 1
    printf("classMFNR::Register_BypassWrite()\n");
#endif
    //*/
    char    fileName[256];
#if CEVA_XM4_DEBUG == 0   // 1/0 for CEVA_XM4 IDE Debug-View
    sprintf(fileName, "..\\..\\bypass\\pHomographyMatrix.dat");
#else
    sprintf(fileName, "bypass\\pHomographyMatrix.dat");
#endif
    
    FILE*   fp = fopen(fileName, "w+b");
    if(fp != NULL)
    {
        for (int k=0; k < nRawFileNum; k++)
        {
            fwrite(pHomoMats[k], sizeof(RK_F32), 9, fp);
        }
        fclose(fp);
    }
    else
    {
        ret = -1;
    }
//*/
//*/
#if CEVA_XM4_DEBUG == 0   // 1/0 for CEVA_XM4 IDE Debug-View
    sprintf(fileName, "..\\..\\bypass\\pHomographyMatrix.txt");
#else
    sprintf(fileName, "bypass\\pHomographyMatrix.txt");
#endif
    fp = fopen(fileName, "w+b");
    if(fp != NULL)
    {
        for (int k=0; k < nRawFileNum; k++)
        {
            for (int i=0; i < 9; i++)
            {
                fprintf(fp,"%.6f ", pHomoMats[k][i]);
                if ((i+1)%3==0)
                {
                    fprintf(fp,"\n");
                }
            }
        }
        fclose(fp);
    }
    else
    {
        ret = -1;
    }
//*/
#endif
    //
    return ret;

} // classMFNR::Register_BypassWrite()


/************************************************************************/
// Func: classMFNR::Register_BypassRead()
// Desc: Register_BypassRead
//   In: fileName       - [in] Output file name
//       nRawFileNum    - [in] RawSrcs data file number
//  Out: pHomoMats      - [out] Homography: [9*nRawFileNum] * 4Byte
// 
// Date: Revised by yousf 20160822
// 
/*************************************************************************/
CODE_MFNR_EX
int classMFNR::Register_BypassRead(int nRawFileNum, RK_F32* pHomoMats[])
{
    //
    int     ret = 0; // return value
#ifdef PC_DEBUG
#if MY_DEBUG_PRINTF == 1
    printf("classMFNR::Register_BypassRead()\n");
#endif
    //*/
    char    fileName[256];
#if CEVA_XM4_DEBUG == 0   // 1/0 for CEVA_XM4 IDE Debug-View
    sprintf(fileName, "..\\..\\bypass\\pHomographyMatrix.dat");
#else
    sprintf(fileName, "bypass\\pHomographyMatrix.dat");
#endif

    FILE*   fp = fopen(fileName, "r+b");
    if(fp != NULL)
    {
        for (int k=0; k < nRawFileNum; k++)
        {
            fread(pHomoMats[k], sizeof(RK_F32), 9, fp);
        }
        fclose(fp);
    }
    else
    {
        ret = -1;
    }
//*/
/*/
#if CEVA_XM4_DEBUG == 0   // 1/0 for CEVA_XM4 IDE Debug-View
    sprintf(fileName, "..\\..\\bypass\\pHomographyMatrix.txt");
#else
    sprintf(fileName, "bypass\\pHomographyMatrix.txt");
#endif
    fp = fopen(fileName, "r+b");
    if(fp != NULL)
    {
        for (int k=0; k < nRawFileNum; k++)
        {
            for (int i=0; i < 9; i++)
            {
                fscanf(fp, "%f", &pHomoMats[k][i]);
                if ((i+1)%3==0)
                {
                    fscanf(fp,"\n");
                }
            }
        }
        fclose(fp);
    }
    else
    {
        ret = -1;
    }
//*/
#endif
    //
    return ret;

} // classMFNR::Register_BypassRead()


/************************************************************************/
// Func: classMFNR::Enhancer()
// Desc: Process Module: Register Interface 
//   In: 
//  Out: 
// 
// Date: Revised by yousf 20160818
// 
/*************************************************************************/
CODE_MFNR_EX
int classMFNR::Enhancer(RK_RawType* pRawDst)
{
    //
    int     ret = 0; // return value
#if MY_DEBUG_PRINTF == 1
    printf("classMFNR::Enhancer()\n");
#endif
    ////-------- TemporalDenoise & BayerWDR & SpatialDenoise
    mDspMem_UsedCount = mDspMem_ResetPos; // Mark Position
    int         nChunkSize;
    int			blkHgt  = RAW_BLK_SIZE;	                // Block Height in Raw Allowed to Read
    int			blkWid  = RAW_BLK_SIZE * RAW_WIN_NUM;	// Block Width  in Raw Allowed to Read

    //// Block32x32n Temp Pointers
    RK_U16*     pDdrRawBase   = NULL;
    RK_U16*     pDspRawBase   = NULL;
    RK_U16*     pDdrRawRef    = NULL;
    RK_U16*     pDspRawRef    = NULL;
    //RK_U16*     pDspWdrBuf    = NULL;
    RK_U16*     pDdrRawDst    = NULL;

    // num Block32x32 of Current Chunk
    int         numBlocks;      

    // DSP Chunk Index
    int         chunkIdx_base;  // odd-even
    int         chunkIdx_ref;   // odd-even
    int         currentBufIdx_wdr;  // odd-even
    int         anotherBufIdx_wdr;  // odd-even


    // Bounding Rectangle of Raw
    RK_U16      nBaseBlkRow;
    RK_U16      nBaseBlkCol;
    RK_U16      nBaseBlkHgt;
    RK_U16      nBaseBlkWid;

    // Valid Data Rectangle in Raw
    RK_S32      nBaseBlkRow_border; // BaseBlock
    RK_S32      nBaseBlkCol_border;
    RK_S32      nBaseBlkHgt_border;
    RK_S32      nBaseBlkWid_border;
    RK_S32      nBaseBlkStride_border;
    RK_S32      nRefBlkRow_border; // RefBlock
    RK_S32      nRefBlkCol_border;
    RK_S32      nRefBlkHgt_border;
    RK_S32      nRefBlkWid_border;
    RK_S32      nRefBlkStride_border;

    // 4PixelAlign Rectangle for DMA
    RK_U16      nBaseBlkRow_4p; // BaseBlock
    RK_U16      nBaseBlkCol_4p;
    RK_U16      nBaseBlkHgt_4p;
    RK_U16      nBaseBlkWid_4p; 
    RK_U16      nRefBlkRow_4p; // RefBlock
    RK_U16      nRefBlkCol_4p;
    RK_U16      nRefBlkHgt_4p;
    RK_U16      nRefBlkWid_4p; 
    RK_U16      nStartCol_4p;
    int         nColCrop;

    // Half Block Size
    RK_U16      nHalfBlkHgt;        // Half Block Hgt
    RK_U16      nHalfBlkWid;        // Half Block Wid

    // Project Result
    RK_S32      minRefBlocksRow;    // min Ref Row in Current Chunk
    RK_S32      maxRefBlocksRow;    // max Ref Row in Current Chunk
    RK_S32      minRefBlocksCol;    // min Ref Col in Current Chunk
    RK_S32      maxRefBlocksCol;    // max Ref Col in Current Chunk
    RK_U16      maxProjRowDist;     // max Ref ProjRowDist in Current Chunk
    RK_U16      maxProjColDist;     // max Ref ProjColDist in Current Chunk

    // Rects of Raw data
    RK_RectExt  rectBase;           // Rect Info of RawBase Chunk
    RK_RectExt  rectRef;            // Rect Info of RawRef Chunk


    //==== pBaseBlocksPoint & pProjBlocksPoint & ... addr in DSP
    // pBaseBlocksPoint & pProjBlocksPoint
    nChunkSize = sizeof(RK_F32) * 2;
    for (int i=0; i < RAW_WIN_NUM; i++)
    {
        // pBaseBlocksPoint // BaseBlocks Center Pointer: 4 Points for n-block(32x32)
        pBaseBlocksPoint[i] = (RK_F32*)&dspMemoryArray[mDspMem_UsedCount];
        mDspMem_UsedCount  += nChunkSize; // current used count
        if (mDspMem_UsedCount > DSP_MEM_SIZE)
        {
#if MY_DEBUG_PRINTF == 1
            printf("Failed to Allocate pBaseBlocksPoint[%d] !\n", i);
#endif
            return ret;
        }
    }
    for (int i=0; i < RAW_WIN_NUM; i++)
    {
        // pProjBlocksPoint // ProjBlocks Center Pointer: 4 Points for n-block(32x32)
        pProjBlocksPoint[i] = (RK_F32*)&dspMemoryArray[mDspMem_UsedCount];
        mDspMem_UsedCount  += nChunkSize; // current used count
        if (mDspMem_UsedCount > DSP_MEM_SIZE)
        {
#if MY_DEBUG_PRINTF == 1
            printf("Failed to Allocate pProjBlocksPoint[%d] !\n", i);
#endif
            return ret;
        }
    }

    // pRawBaseBlocksDspChunks // RawBaseBlocks DSP Chunks: (32+2*2)x(32n+2*4) * 2B * 2  ExpandedBoundary=(2,2)
    nChunkSize                 = sizeof(RK_U16) * (blkHgt+2*RAW_BLK_EXTEND_ROW) * (blkWid+2*RAW_BLK_EXTEND_COL);
    pRawBaseBlocksDspChunks[0] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount         += nChunkSize; // current used count
    pRawBaseBlocksDspChunks[1] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount         += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pRawBaseBlocksDspChunks !\n");
#endif
        return ret;
    }
    // pRawBaseFilterDspChunk // RawBaseFilter DSP Chunk: (32+2*2)x(32n+2*4) * 2B * 2  ExpandedBoundary=(2,2)
    nChunkSize             = sizeof(RK_U16) * (blkHgt+2*RAW_BLK_EXTEND_ROW) * (blkWid+2*RAW_BLK_EXTEND_COL);
    pRawBaseFilterDspChunk = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount     += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pRawBaseFilterDspChunk !\n");
#endif
        return ret;
    }
    //pRawBaseThreshDspChunk // RawBaseThresh DSP Chunk: 32x32n * 1B
    nChunkSize             = sizeof(RK_U16) * blkHgt * blkWid;
    pRawBaseThreshDspChunk = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount     += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pRawBaseThreshDspChunk !\n");
#endif
        return ret;
    }

    // pRawRefBlocksDspChunks // RawRefBlocks DSP Chunks: (32+2*9)x(32n+2*12) * 2B * 2  ExpandedBoundary=(9,12)
    nChunkSize                = sizeof(RK_U16) * (blkHgt+2*RAW_REF_EXTEND_ROW) * (blkWid+2*RAW_REF_EXTEND_COL);
    pRawRefBlocksDspChunks[0] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount        += nChunkSize; // current used count
    pRawRefBlocksDspChunks[1] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount        += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pRawRefBlocksDspChunks !\n");
#endif
        return ret;
    }
    // pRawRefFilterDspChunk // RawRefFilter DSP Chunk:  (32+2*9)x(32n+2*11) * 2B ExpandedBoundary=(9,11)
    nChunkSize            = sizeof(RK_U16) * (blkHgt+2*RAW_REF_EXTEND_ROW) * (blkWid+2*RAW_REF_EXTEND_COL);
    pRawRefFilterDspChunk = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount    += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pRawRefFilterDspChunk !\n");
#endif
        return ret;
    }

    // pRawDstSumDspChunk // RawDstSum DSP Chunk: 32x32n * 2B
    nChunkSize         = sizeof(RK_U16) * blkHgt * blkWid;
    pRawDstSumDspChunk = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pRawDstSumDspChunk !\n");
#endif
        return ret;
    }
    // pRawDstWgtDspChunk // RawDstWgt DSP Chunk: 32x32n * 1B
    nChunkSize         = sizeof(RK_U8) * blkHgt * blkWid;
    pRawDstWgtDspChunk = (RK_U8*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pRawDstWgtDspChunk !\n");
#endif
        return ret;
    }


    // pWdrRawBlockBuf // BlkBuf: (2+32)x(1+32n+1)*2B, n=2 -> 32*n=64
    int nWdrBufWid     = RAW_BLK_SIZE * RAW_WIN_NUM + 2; // 1+32*2+1
    nChunkSize         = sizeof(RK_U16) * (RAW_BLK_SIZE+2) * nWdrBufWid;//
    pWdrRawBlockBuf[0] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    pWdrRawBlockBuf[1] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrRawBlockBuf !\n");
#endif
        return ret;
    }
    // pWdrRawRowBuf // RowBuf: 2xRawWid*2B
    int nRowsBufWid    = CEIL(mRawWid*1.0/(RAW_BLK_SIZE*RAW_WIN_NUM))*RAW_BLK_SIZE*RAW_WIN_NUM + 2; // 64-Align
    nChunkSize         = sizeof(RK_U16) * 2 * nRowsBufWid;
    pWdrRawRowBuf      = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrRawRowBuf !\n");
#endif
        return ret;
    }
    // pWdrRawColBuf // ColBuf: 32x1*2B
    nChunkSize         = sizeof(RK_U16) * RAW_BLK_SIZE;
    pWdrRawColBuf      = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrRawColBuf !\n");
#endif
        return ret;
    }
    // pWdrRawBlockRect // Rects: 1x4*2B
    nChunkSize          = sizeof(RK_U16) * 4;//
    pWdrRawBlockRect[0] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount  += nChunkSize; // current used count
    pWdrRawBlockRect[1] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount  += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrRawBlockRect !\n");
#endif
        return ret;
    }

    // pWdrThumbWgtTable // Thumb Weight Table: 9x256*2B
//     nChunkSize         = sizeof(RK_U16) * 9 * 256;
//     pWdrThumbWgtTable  = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
//     mDspMem_UsedCount += nChunkSize; // current used count
//     if (mDspMem_UsedCount > DSP_MEM_SIZE)
//     {
//         printf("Failed to Allocate pWdrThumbWgtTable !\n");
//         return ret;
//     }
    // pWdrScaleTable // ScaleTabale[expouse_times] 961*2B
    nChunkSize         = sizeof(RK_U16) * 961;
    pWdrScaleTable     = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrScaleTable !\n");
#endif
        return ret;
    }

    // pWdrLeft & pWdrRight // 32x16*2B byte space   2K store 32 line left and right, align 16, actually 9 valid..
    nChunkSize         = sizeof(RK_U16) * 32 * 16 * 2;
    pWdrLeftRight      = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrLeftRight !\n");
#endif
        return ret;
    }

    // pWdrGainMat // Result: 32x32n*2B
    nChunkSize         = sizeof(RK_U16) * RAW_BLK_SIZE * RAW_BLK_SIZE*RAW_WIN_NUM;
    pWdrGainMat        = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrGainMat !\n");
#endif
        return ret;
    }
    // pWdrRawResult // Result: 32x32n*2B
    nChunkSize         = sizeof(RK_U16) * RAW_BLK_SIZE * RAW_BLK_SIZE*RAW_WIN_NUM;
    pWdrRawResult      = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrRawResult !\n");
#endif
        return ret;
    }

    // init
    memset(pWdrRawBlockBuf[0], 0, sizeof(RK_U16) * (RAW_BLK_SIZE+2) * (RAW_BLK_SIZE*RAW_WIN_NUM+2));
    memset(pWdrRawBlockBuf[1], 1, sizeof(RK_U16) * (RAW_BLK_SIZE+2) * (RAW_BLK_SIZE*RAW_WIN_NUM+2));
    memset(pWdrRawRowBuf,      2, sizeof(RK_U16) * 2 * nRowsBufWid);
    memset(pWdrRawColBuf,      3, sizeof(RK_U16) * RAW_BLK_SIZE);

    
    //////////////////////////////////////////////////////////////////////////
    ////---- Processing Block(#i, #j)
    chunkIdx_base     = 1; // odd-even init
    currentBufIdx_wdr = 1; // odd-even init
    for (int i=0; i < mRawHgt; i += blkHgt)
    {
        for (int j=0; j < mRawWid; j += blkWid)
        {
            // num Block32x32 of Current Chunk
            numBlocks   = (MIN(blkWid, mRawWid-j) + RAW_BLK_SIZE - 1) / RAW_BLK_SIZE; 

            // Block(#i,#j) Valid Range // block(row, col) 32x32n
            nBaseBlkRow        = i;
            nBaseBlkCol        = j;
            nBaseBlkHgt        = blkHgt;
            nBaseBlkWid        = blkWid;
            rectBase.rowUseful = nBaseBlkRow;// Rect Useful
            rectBase.colUseful = nBaseBlkCol;
            rectBase.hgtUseful = MIN(nBaseBlkHgt, mRawHgt - nBaseBlkRow);
            rectBase.widUseful = MIN(nBaseBlkWid, mRawWid - nBaseBlkCol);
            // Bounding Rectangle of RawBase // Maybe Include Invalid Data
            nBaseBlkRow_border    = nBaseBlkRow - RAW_BLK_BORDER;
            nBaseBlkCol_border    = nBaseBlkCol - RAW_BLK_BORDER;
            nBaseBlkCol_border    = ALIGN_4PIXEL_START(nBaseBlkCol_border);
            nBaseBlkHgt_border    = nBaseBlkHgt + 2 * RAW_BLK_EXTEND_ROW;
            nBaseBlkWid_border    = nBaseBlkWid + 2 * RAW_BLK_EXTEND_COL;
            nBaseBlkWid_border    = ALIGN_4PIXEL_WIDTH(nBaseBlkWid_border);
            nBaseBlkStride_border = (nBaseBlkWid + 2 * RAW_BLK_EXTEND_COL) * sizeof(RK_U16); // stride in DSP
            rectBase.rowExtend    = nBaseBlkRow_border; // Rect Extend
            rectBase.colExtend    = nBaseBlkCol_border;
            rectBase.hgtExtend    = nBaseBlkHgt_border;
            rectBase.widExtend    = nBaseBlkWid_border;
            rectBase.strideExtend = nBaseBlkStride_border;
            // Valid Data Rectangle in RawBase // Only Include Valid Data
            nBaseBlkRow_4p    = MAX(nBaseBlkRow_border, 0);
            nBaseBlkCol_4p    = MAX(nBaseBlkCol_border, 0);
            nBaseBlkHgt_4p    = MIN(nBaseBlkHgt_border - (nBaseBlkRow_4p - nBaseBlkRow_border), mRawHgt - nBaseBlkRow_4p);
            nBaseBlkWid_4p    = MIN(nBaseBlkWid_border - (nBaseBlkCol_4p - nBaseBlkCol_border), mRawWid - nBaseBlkCol_4p);
            nBaseBlkCol_4p    = ALIGN_4PIXEL_START(nBaseBlkCol_4p); // 4PixelAlign Rectangle for DMA
            nStartCol_4p      = nBaseBlkCol_4p - nBaseBlkCol_4p;
            nBaseBlkWid_4p    = ALIGN_4PIXEL_WIDTH(nStartCol_4p + nBaseBlkWid_4p);
            rectBase.rowValid = nBaseBlkRow_4p;// Rect Valid
            rectBase.colValid = nBaseBlkCol_4p;
            rectBase.hgtValid = nBaseBlkHgt_4p;
            rectBase.widValid = nBaseBlkWid_4p;

            // DMA
            pDdrRawBase   = (RK_U16*)((RK_U8*)pRawSrcs[mBasePicNum] + rectBase.rowValid * mRawStride + rectBase.colValid * 5/4);
            chunkIdx_base = (chunkIdx_base + 1) & 0x1; // odd-even
            pDspRawBase   = (RK_U16*)((RK_U8*)pRawBaseBlocksDspChunks[chunkIdx_base] 
                          + (rectBase.rowValid - rectBase.rowExtend) * rectBase.strideExtend 
                          + (rectBase.colValid - rectBase.colExtend) * sizeof(RK_U16));
            memset(pRawBaseBlocksDspChunks[chunkIdx_base], 0, 
                sizeof(RK_U16) * (blkHgt+2*RAW_BLK_EXTEND_ROW) * (blkWid+2*RAW_BLK_EXTEND_COL));
            RKDMA_ReadRaw10bit2DSP((U32)pDdrRawBase, (U32)pDspRawBase, 
                rectBase.widValid, rectBase.hgtValid, mRawStride, rectBase.strideExtend, rectBase.colValid);
               
#if USE_MOTION_DETECT == 1
            // Filter
            memset(pRawBaseFilterDspChunk, 0, sizeof(RK_U16) * (blkHgt+2*RAW_BLK_EXTEND_ROW) * (blkWid+2*RAW_BLK_EXTEND_COL));
            MotionDetectFilter(pRawBaseBlocksDspChunks[chunkIdx_base], rectBase, pRawBaseFilterDspChunk);

            // MotionDetectTable
            LookupMotionDetectThresh(pRawBaseBlocksDspChunks[chunkIdx_base], rectBase, MotionDetectTable, pRawBaseThreshDspChunk);
#endif

            // RawDst init  = RawBase
            RawDstInit(rectBase, pRawBaseBlocksDspChunks[chunkIdx_base], pRawDstSumDspChunk, pRawDstWgtDspChunk);
            
            // RawRef
            chunkIdx_ref = 1; // odd-even init
            for (int k=0; k < mRawFileNum; k++)
            {
                if (k != mBasePicNum)
                {
                    // Find Bounding Rectangle of numBlocks-ProjPoints
                    minRefBlocksRow = +0xFFFF;  // min Ref Row in 4-ImageCornerBlocks
                    maxRefBlocksRow = -0xFFFF;  // max Ref Row in 4-ImageCornerBlocks
                    minRefBlocksCol = +0xFFFF;  // min Ref Col in 4-ImageCornerBlocks
                    maxRefBlocksCol = -0xFFFF;  // max Ref Col in 4-ImageCornerBlocks
                    for (int n=0; n < numBlocks; n++)
                    {
                        nHalfBlkHgt = MIN(nBaseBlkHgt, RAW_BLK_SIZE) / 2;   // Half Block Hgt in Raw
                        nHalfBlkWid = MIN(nBaseBlkWid - n * RAW_BLK_SIZE, RAW_BLK_SIZE) / 2;   // Half Block Wid in Raw

                        // Center in LumaBase Block#n
                        pBaseBlocksPoint[n][0] = (RK_F32)(nBaseBlkRow + nHalfBlkHgt);     // Block32x32 Center Row in Raw
                        pBaseBlocksPoint[n][1] = (RK_F32)(nBaseBlkCol + nHalfBlkWid + n * RAW_BLK_SIZE); // Block32x32 Center Col in Raw
                        pBaseBlocksPoint[n][0] = (RK_F32)(pBaseBlocksPoint[n][0] / 2); // in Luma
                        pBaseBlocksPoint[n][1] = (RK_F32)(pBaseBlocksPoint[n][1] / 2); // in Luma

                        // Project
                        ret = PerspectProject(pHomographyMatrix[k], pBaseBlocksPoint[n], pProjBlocksPoint[n]);

                        // Center in LumaBase Block#n -> TopLeft in RawBase Block#n
                        pBaseBlocksPoint[n][0] = pBaseBlocksPoint[n][0] * 2 - nHalfBlkHgt;
                        pBaseBlocksPoint[n][1] = pBaseBlocksPoint[n][1] * 2 - nHalfBlkWid;
                        // Center in LumaRef Block#n -> TopLeft in RawRefe Block#n
                        pProjBlocksPoint[n][0] = (RK_F32)ROUND_I32(pProjBlocksPoint[n][0]) * 2 - nHalfBlkHgt;
                        pProjBlocksPoint[n][1] = (RK_F32)ROUND_I32(pProjBlocksPoint[n][1]) * 2 - nHalfBlkWid;
                        // Round
//                         pProjBlocksPoint[n][0] = (RK_F32)ROUND_I32(pProjBlocksPoint[n][0]);
//                         pProjBlocksPoint[n][1] = (RK_F32)ROUND_I32(pProjBlocksPoint[n][1]);

                        // min&max Row of numBlocks-ProjPoints
                        if (pProjBlocksPoint[n][0] < minRefBlocksRow)
                        {
                            minRefBlocksRow = (RK_S32)pProjBlocksPoint[n][0];
                        }
                        if (pProjBlocksPoint[n][0] > maxRefBlocksRow)
                        {
                            maxRefBlocksRow = (RK_S32)pProjBlocksPoint[n][0];
                        }
                        // min&max Col of numBlocks-ProjPoints
                        if (pProjBlocksPoint[n][1] < minRefBlocksCol)
                        {
                            minRefBlocksCol = (RK_S32)pProjBlocksPoint[n][1];
                        }
                        if (pProjBlocksPoint[n][1] > maxRefBlocksCol)
                        {
                            maxRefBlocksCol = (RK_S32)pProjBlocksPoint[n][1];
                        }
                    } // for n

                    // Compute ProjWinSize
                    maxProjRowDist = maxRefBlocksRow - minRefBlocksRow; // max Ref ProjRowDist in 4-ImageCornerBlocks
                    maxProjColDist = maxRefBlocksCol - minRefBlocksCol; // max Ref ProjColDist in 4-ImageCornerBlocks
                    
                    //////////////////////////////////////////////////////////////////////////
                    //---- DMA: RawRef(DDR10bit->DSP16bit)
                    // Block(#i,#j) Valid Range
                    rectRef.rowUseful = minRefBlocksRow;// Rect Useful
                    rectRef.colUseful = minRefBlocksCol;
                    rectRef.hgtUseful = MIN(maxProjRowDist + nBaseBlkHgt,  mRawHgt - minRefBlocksRow);
                    rectRef.widUseful = MIN(maxProjColDist + RAW_BLK_SIZE, mRawWid - minRefBlocksCol);
                    // Bounding Rectangle of RawRef
                    nRefBlkRow_border    = minRefBlocksRow - RAW_BLK_BORDER; // Maybe Include Invalid Data
                    nRefBlkCol_border    = minRefBlocksCol - RAW_BLK_BORDER;
                    nRefBlkCol_border    = ALIGN_4PIXEL_START(nRefBlkCol_border);
                    nRefBlkHgt_border    = maxProjRowDist + nBaseBlkHgt + 2*RAW_BLK_BORDER;//MIN(blkHgt, mRawHgt-nBaseBlkRow) + maxProjRowDist + 2*RAW_BLK_BORDER;
                    nRefBlkWid_border    = maxProjColDist + RAW_BLK_SIZE + 2*(minRefBlocksCol-nRefBlkCol_border);//MIN(blkWid, mRawWid-nBaseBlkCol) + maxProjColDist + 2*RAW_BLK_BORDER;
                    nRefBlkWid_border    = ALIGN_4PIXEL_WIDTH(nRefBlkWid_border);
                    nRefBlkStride_border = nRefBlkWid_border * sizeof(RK_U16); // stride in DSP
                    rectRef.rowExtend    = nRefBlkRow_border; // Rect Extend
                    rectRef.colExtend    = nRefBlkCol_border;
                    rectRef.hgtExtend    = nRefBlkHgt_border;
                    rectRef.widExtend    = nRefBlkWid_border;
                    rectRef.strideExtend = nRefBlkStride_border;
                    // Valid Data Rectangle in RawRef
                    nRefBlkRow_4p    = MAX(nRefBlkRow_border, 0);// Only Include Valid Data
                    nRefBlkCol_4p    = MAX(nRefBlkCol_border, 0);
                    nRefBlkHgt_4p    = MIN(nRefBlkHgt_border - (nRefBlkRow_4p - nRefBlkRow_border), mRawHgt - nRefBlkRow_4p);
                    nRefBlkWid_4p    = MIN(nRefBlkWid_border - (nRefBlkCol_4p - nRefBlkCol_border), mRawWid - nRefBlkCol_4p);
                    nRefBlkCol_4p    = ALIGN_4PIXEL_START(nRefBlkCol_4p);
                    nStartCol_4p     = nRefBlkCol_4p - nRefBlkCol_4p;
                    nRefBlkWid_4p    = ALIGN_4PIXEL_WIDTH(nStartCol_4p + nRefBlkWid_4p);
                    rectRef.rowValid = nRefBlkRow_4p;// Rect Valid
                    rectRef.colValid = nRefBlkCol_4p;
                    rectRef.hgtValid = nRefBlkHgt_4p;
                    rectRef.widValid = nRefBlkWid_4p;
                    // Rect Useful
                    nColCrop           = rectRef.colValid - rectRef.colUseful;
                    rectRef.colUseful += MAX(0, nColCrop);
                    rectRef.widUseful -= MAX(0, nColCrop);

                    // DMA
                    pDdrRawRef   = (RK_U16*)((RK_U8*)pRawSrcs[k] + rectRef.rowValid * mRawStride + rectRef.colValid * 5/4); // stride = mThumbStride
                    chunkIdx_ref = (chunkIdx_ref + 1) & 0x1; // odd-even
                    pDspRawRef   = (RK_U16*)((RK_U8*)pRawRefBlocksDspChunks[chunkIdx_ref] 
                                 + (rectRef.rowValid - rectRef.rowExtend) * rectRef.strideExtend 
                                 + (rectRef.colValid - rectRef.colExtend) * sizeof(RK_U16));
                    memset(pRawRefBlocksDspChunks[chunkIdx_ref], 0, 
                        sizeof(RK_U16) * (blkHgt+2*RAW_REF_EXTEND_ROW) * (blkWid+2*RAW_REF_EXTEND_COL));
                    RKDMA_ReadRaw10bit2DSP((U32)pDdrRawRef, (U32)pDspRawRef, 
                        rectRef.widValid, rectRef.hgtValid, mRawStride, rectRef.strideExtend, rectRef.colValid);

#if USE_MOTION_DETECT == 1
                    // Filter
                    memset(pRawRefFilterDspChunk, 0, sizeof(RK_U16) * (blkHgt+2*RAW_REF_EXTEND_ROW) * (blkWid+2*RAW_REF_EXTEND_COL));
                    MotionDetectFilter(pRawRefBlocksDspChunks[chunkIdx_ref], rectRef, pRawRefFilterDspChunk);
#endif

                    // Temporal Denoise
                    TemporalDenoise(pRawBaseFilterDspChunk, rectBase, pBaseBlocksPoint, pRawBaseThreshDspChunk, 
                        numBlocks, pRawRefFilterDspChunk, rectRef, pProjBlocksPoint, 
                        pRawRefBlocksDspChunks[chunkIdx_ref], mRawWid, mRawHgt, 
                        pRawDstSumDspChunk, pRawDstWgtDspChunk);

                } // if k
            } // for k
            
            //// Normalization
            RawDstNormalize(rectBase, mIspGain, pRawDstSumDspChunk, pRawDstWgtDspChunk);


            //////////////////////////////////////////////////////////////////////////
            // TemporalDenoise Result
            /*/ DMA 
            pDdrRawDst = (RK_U16*)((RK_U8*)pRawDst + rectBase.rowUseful * mRawStride + rectBase.colUseful * 5/4); // stride = mThumbStride
            RKDMA_WriteRaw16bit2DDR((U32)pRawDstSumDspChunk, (U32)pDdrRawDst, rectBase.widUseful, rectBase.hgtUseful, 
                rectBase.widUseful*sizeof(RK_U16), mRawStride, rectBase.colUseful);
            //*/
            

            
            //////////////////////////////////////////////////////////////////////////
            //// Bayer WDR
            // Buf Idx
            currentBufIdx_wdr = (currentBufIdx_wdr + 1) & 0x1; // odd-even for LoadData
            anotherBufIdx_wdr = (currentBufIdx_wdr + 1) & 0x1; // odd-even for Process
            // Rect Info
            pWdrRawBlockRect[currentBufIdx_wdr][0] = rectBase.rowUseful; // =i;
            pWdrRawBlockRect[currentBufIdx_wdr][1] = rectBase.colUseful; // =j;
            pWdrRawBlockRect[currentBufIdx_wdr][2] = rectBase.hgtUseful;
            pWdrRawBlockRect[currentBufIdx_wdr][3] = rectBase.widUseful;

            // Fill Block32x64 from TemporalDenoise
            CopyBlockData(pRawDstSumDspChunk, pWdrRawBlockBuf[currentBufIdx_wdr] + 2 * nWdrBufWid + 1,  
                blkWid, blkHgt, blkWid*2, nWdrBufWid*2);

            // Fill 2-TopExternalRows from RowBuf
            CopyBlockData(pWdrRawRowBuf + j, pWdrRawBlockBuf[currentBufIdx_wdr], 
                nWdrBufWid, 2, nRowsBufWid*2, nWdrBufWid*2);

            // Fill 1-LeftCol from ColBuf
            CopyBlockData(pWdrRawColBuf, pWdrRawBlockBuf[currentBufIdx_wdr]+2*nWdrBufWid, 
                1, RAW_BLK_SIZE, 2, nWdrBufWid*2);

            // Update 1-RightCol
            CopyBlockData(pWdrRawBlockBuf[currentBufIdx_wdr]+2*nWdrBufWid+RAW_BLK_SIZE*RAW_WIN_NUM, pWdrRawColBuf, 
                1, RAW_BLK_SIZE, nWdrBufWid*2, 2);

            // 
            if (i==0 && j==0)
            {
                // First Block of Image
                continue;
            }
            else
            {
                // Fill 1-RightCol from AnotherBuf
                CopyBlockData(pWdrRawBlockBuf[currentBufIdx_wdr] + 2*nWdrBufWid + 1, 
                              pWdrRawBlockBuf[anotherBufIdx_wdr] + 2*nWdrBufWid + RAW_BLK_SIZE*RAW_WIN_NUM+1, 
                              1, RAW_BLK_SIZE, nWdrBufWid*2, nWdrBufWid*2);


                // Update 2-TopRows to RowBuf
                CopyBlockData(pWdrRawBlockBuf[anotherBufIdx_wdr] + RAW_BLK_SIZE*nWdrBufWid, 
                              pWdrRawRowBuf + pWdrRawBlockRect[anotherBufIdx_wdr][1], 
                              nWdrBufWid, 2, nWdrBufWid*2, nRowsBufWid*2);


                //////////////////////////////////////////////////////////////////////////
                // BayerWDR
                wdr_process_block(
                    rectBase.colUseful,                 // [in] x of block in Raw
                    rectBase.rowUseful,                 // [in] y of block in Raw
                    rectBase.widUseful,                 // [in] min(64, valid)
                    rectBase.hgtUseful,                 // [in] min(32, valid)
                    ((mRawWid+128)/256+1),	            // [in] (raw_width+128)/256+1 floor((4164+128)/256)+1
                    66,	                                // [in] buffer stride         66
                    64,		                            // [in] picture stride        64
                    pWdrRawBlockBuf[anotherBufIdx_wdr], // [in] input buf             34x66*2B
                    pWdrThumbWgtTable,	                // [in] thumb weight table,   9x256*2B
                    pWdrScaleTable,                     // [in] tabale[expouse_times] 961*2B
                    pWdrGainMat,                        // [out] Gain Matrix          32x64*2B
                    pWdrRawResult,                      // [out] WDR result           32x64*2B
                    pWdrLeftRight);                     // [in] 2*32x16*2B byte space   2K store 32 line left and right, align 16, actually 9 valid..
                
                // DMA
                pDdrRawDst = (RK_U16*)((RK_U8*)pRawDst 
                    + pWdrRawBlockRect[anotherBufIdx_wdr][0] * mRawStride 
                    + pWdrRawBlockRect[anotherBufIdx_wdr][1] * 5/4); // stride = mThumbStride
                RKDMA_WriteRaw16bit2DDR((U32)pWdrRawResult, (U32)pDdrRawDst, 
                    pWdrRawBlockRect[anotherBufIdx_wdr][3], pWdrRawBlockRect[anotherBufIdx_wdr][2], // w, h
                    pWdrRawBlockRect[anotherBufIdx_wdr][3]*sizeof(RK_U16), mRawStride, pWdrRawBlockRect[anotherBufIdx_wdr][1]);
                //*/

            } // WDR
            
        } // for j
    } // for i
    

    //// Processing Last Block(#end, #end)
    // BayerWDR
    wdr_process_block(
        rectBase.colUseful,                 // [in] x of block in Raw
        rectBase.rowUseful,                 // [in] y of block in Raw
        rectBase.widUseful,                 // [in] min(64, valid)
        rectBase.hgtUseful,                 // [in] min(32, valid)
        ((mRawWid+128)/256+1),	            // [in] (raw_width+128)/256+1 floor((4164+128)/256)+1
        66,	                                // [in] buffer stride         66
        64,		                            // [in] picture stride        64
        pWdrRawBlockBuf[currentBufIdx_wdr], // [in] input buf             34x66*2B
        pWdrThumbWgtTable,	                // [in] thumb weight table,   9x256*2B
        pWdrScaleTable,                     // [in] tabale[expouse_times] 961*2B
        pWdrGainMat,                        // [out] Gain Matrix          32x64*2B
        pWdrRawResult,                      // [out] WDR result           32x64*2B
        pWdrLeftRight);                     // [in] 2*32x16*2B byte space   2K store 32 line left and right, align 16, actually 9 valid..

    // DMA
    pDdrRawDst = (RK_U16*)((RK_U8*)pRawDst 
        + pWdrRawBlockRect[currentBufIdx_wdr][0] * mRawStride 
        + pWdrRawBlockRect[currentBufIdx_wdr][1] * 5/4); // stride = mThumbStride
    RKDMA_WriteRaw16bit2DDR((U32)pWdrRawResult, (U32)pDdrRawDst, 
        pWdrRawBlockRect[currentBufIdx_wdr][3], pWdrRawBlockRect[currentBufIdx_wdr][2], // w, h
        pWdrRawBlockRect[currentBufIdx_wdr][3]*sizeof(RK_U16), mRawStride, pWdrRawBlockRect[currentBufIdx_wdr][1]);
    //*/




    //
    return ret;
}


/************************************************************************/
// Func: classMFNR::Enhancer_Modify()
// Desc: Process Module: Register Interface 
//   In: 
//  Out: 
// 
// Date: Revised by yousf 20160824
// 
/*************************************************************************/
CODE_MFNR_EX
int classMFNR::Enhancer_Modify(RK_RawType* pRawDst)
{
    //
    int     ret = 0; // return value
#if MY_DEBUG_PRINTF == 1
    printf("classMFNR::Enhancer_Modify()\n");
#endif
    ////-------- TemporalDenoise & BayerWDR & SpatialDenoise
    int         nChunkSize;
    int			blkHgt  = RAW_BLK_SIZE;	                // Block Height in Raw Allowed to Read
    int			blkWid  = RAW_BLK_SIZE * RAW_WIN_NUM;	// Block Width  in Raw Allowed to Read

    //// Block32x32n Temp Pointers
    RK_U16*     pDdrRawBase   = NULL;
    RK_U16*     pDspRawBase   = NULL;
    RK_U16*     pDdrRawRef    = NULL;
    RK_U16*     pDspRawRef    = NULL;
    RK_U16*     pDspWdrBuf    = NULL;
    RK_U16*     pDdrRawDst    = NULL;

    // num Block32x32 of Current Chunk
    int         numBlocks;      

    // DSP Chunk Index
    int         chunkIdx_nr;    // odd-even
    int         currentBufIdx_wdr;  // odd-even
    int         anotherBufIdx_wdr;  // odd-even

    // Bounding Rectangle of Raw
    RK_U16      nBaseBlkRow;
    RK_U16      nBaseBlkCol;
    RK_U16      nBaseBlkHgt;
    RK_U16      nBaseBlkWid;

    // Valid Data Rectangle in Raw
    RK_S32      nBaseBlkRow_border; // BaseBlock
    RK_S32      nBaseBlkCol_border;
    RK_S32      nBaseBlkHgt_border;
    RK_S32      nBaseBlkWid_border;
    RK_S32      nBaseBlkStride_border;
    RK_S32      nRefBlkRow_border; // RefBlock
    RK_S32      nRefBlkCol_border;
    RK_S32      nRefBlkHgt_border;
    RK_S32      nRefBlkWid_border;
    RK_S32      nRefBlkStride_border;

    // 4PixelAlign Rectangle for DMA
    RK_U16      nBaseBlkRow_4p; // BaseBlock
    RK_U16      nBaseBlkCol_4p;
    RK_U16      nBaseBlkHgt_4p;
    RK_U16      nBaseBlkWid_4p; 
    RK_U16      nRefBlkRow_4p; // RefBlock
    RK_U16      nRefBlkCol_4p;
    RK_U16      nRefBlkHgt_4p;
    RK_U16      nRefBlkWid_4p; 
    RK_U16      nStartCol_4p;
    int         nRowCrop;
    int         nColCrop;

    // Half Block Size
    RK_U16      nHalfBlkHgt;        // Half Block Hgt
    RK_U16      nHalfBlkWid;        // Half Block Wid

    // Project Result
    RK_S32      minRefBlocksRow;    // min Ref Row in Current Chunk
    RK_S32      maxRefBlocksRow;    // max Ref Row in Current Chunk
    RK_S32      minRefBlocksCol;    // min Ref Col in Current Chunk
    RK_S32      maxRefBlocksCol;    // max Ref Col in Current Chunk
    RK_U16      maxProjRowDist;     // max Ref ProjRowDist in Current Chunk
    RK_U16      maxProjColDist;     // max Ref ProjColDist in Current Chunk

    // Rects of Raw data
    RK_RectExt  rects[RK_MAX_FILE_NUM]; // Rect Info of Raw Chunk


    //==== DSP Malloc: pRawBlkPoints & pRawBlkChunks & pRawDstChunk addr in DSP
    mDspMem_UsedCount = mDspMem_ResetPos; // Mark Position
    // pRawBlkPoints[RK_MAX_FILE_NUM]
    nChunkSize = sizeof(RK_F32) * 2;
    for (int k=0; k < mRawFileNum; k++)
    {
        // pRawBlkPoints[k][i]: [Y,X]
        pRawBlkPoints[k] = (RK_F32*)&dspMemoryArray[mDspMem_UsedCount];
        mDspMem_UsedCount  += nChunkSize*RAW_WIN_NUM; // current used count
        if (mDspMem_UsedCount > DSP_MEM_SIZE)
        {
#if MY_DEBUG_PRINTF == 1
            printf("Failed to Allocate pRawBlkPoints[%d] !\n", k);
#endif
            return ret;
        }
    }
    // pRawBlkChunks[2][RK_MAX_FILE_NUM]
    nChunkSize = sizeof(RK_U16) * (RAW_BLK_SIZE+2*4) * (RAW_BLK_SIZE*RAW_WIN_NUM+2*8);
    for (int n=0; n < 2; n++)
    {
        for (int k=0; k < mRawFileNum; k++)
        {
            pRawBlkChunks[n][k] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
            mDspMem_UsedCount  += nChunkSize; // current used count
            if (mDspMem_UsedCount > DSP_MEM_SIZE)
            {
#if MY_DEBUG_PRINTF == 1
                printf("Failed to Allocate pRawBlkChunks[%d][%d] !\n", n, k);
#endif
                return ret;
            }
            // init
            for (int i=0; i < nChunkSize/2; i++)
            {
                pRawBlkChunks[n][k][i] = 64;
            }
        }
    }
    // pRawDstChunk
    nChunkSize         = sizeof(RK_U16) * blkHgt * blkWid;
    pRawDstChunk       = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pRawDstChunk !\n");
#endif
        return ret;
    }


    // pWdrRawBlockBuf // BlkBuf: (2+32)x(1+32n+1)*2B, n=2 -> 32*n=64
    int nWdrBufWid     = RAW_BLK_SIZE * RAW_WIN_NUM + 2; // 1+32*2+1
    nChunkSize         = sizeof(RK_U16) * (RAW_BLK_SIZE+2) * nWdrBufWid;//
    pWdrRawBlockBuf[0] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    pWdrRawBlockBuf[1] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrRawBlockBuf !\n");
#endif
        return ret;
    }
    // pWdrRawRowBuf // RowBuf: 2xRawWid*2B
    int nRowsBufWid;//    = CEIL(mRawWid*1.0/(RAW_BLK_SIZE*RAW_WIN_NUM))*RAW_BLK_SIZE*RAW_WIN_NUM + 2; // 64-Align
    if (RAW_BLK_SIZE*RAW_WIN_NUM == 64)
    {
    	nRowsBufWid    = ((mRawWid >> 6) << 6) + 2;
    }
    else
    {
    	nRowsBufWid    = CEIL(mRawWid*1.0/(RAW_BLK_SIZE*RAW_WIN_NUM))*RAW_BLK_SIZE*RAW_WIN_NUM + 2; // 64-Align
    }
    nChunkSize         = sizeof(RK_U16) * 2 * nRowsBufWid;
    pWdrRawRowBuf      = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrRawRowBuf !\n");
#endif
        return ret;
    }
    // pWdrRawColBuf // ColBuf: 32x1*2B
    nChunkSize         = sizeof(RK_U16) * RAW_BLK_SIZE;
    pWdrRawColBuf      = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrRawColBuf !\n");
#endif
        return ret;
    }
    // pWdrRawBlockRect // Rects: 1x4*2B
    nChunkSize          = sizeof(RK_U16) * 4;//
    pWdrRawBlockRect[0] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount  += nChunkSize; // current used count
    pWdrRawBlockRect[1] = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount  += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrRawBlockRect !\n");
#endif
        return ret;
    }

    // pWdrThumbWgtTable // Thumb Weight Table: 9x256*2B
    //     nChunkSize         = sizeof(RK_U16) * 9 * 256;
    //     pWdrThumbWgtTable  = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    //     mDspMem_UsedCount += nChunkSize; // current used count
    //     if (mDspMem_UsedCount > DSP_MEM_SIZE)
    //     {
    //         printf("Failed to Allocate pWdrThumbWgtTable !\n");
    //         return ret;
    //     }
    // pWdrScaleTable // ScaleTabale[expouse_times] 961*2B
    nChunkSize         = sizeof(RK_U16) * 961;
    pWdrScaleTable     = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count

	
	// add by zxy for LUT scale tab
	lutWdrTable(pWdrScaleTable, mIspGain/* IspGain */); 


	
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrScaleTable !\n");
#endif
        return ret;
    }

    // pWdrLeft & pWdrRight // 32x16*2B byte space   2K store 32 line left and right, align 16, actually 9 valid..
    nChunkSize         = sizeof(RK_U16) * 32 * 16 * 2;
    pWdrLeftRight      = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrLeftRight !\n");
#endif
        return ret;
    }

    // pWdrGainMat // Result: 32x32n*2B
    nChunkSize         = sizeof(RK_U16) * RAW_BLK_SIZE * RAW_BLK_SIZE*RAW_WIN_NUM;
    pWdrGainMat        = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrGainMat !\n");
#endif
        return ret;
    }

	// init                                                                                         
	memset(pWdrRawBlockBuf[0], 0, sizeof(RK_U16) * (RAW_BLK_SIZE+2) * (RAW_BLK_SIZE*RAW_WIN_NUM+2));
	memset(pWdrRawBlockBuf[1], 0, sizeof(RK_U16) * (RAW_BLK_SIZE+2) * (RAW_BLK_SIZE*RAW_WIN_NUM+2));
	memset(pWdrRawRowBuf,      0, sizeof(RK_U16) * 2 * nRowsBufWid);                                
	memset(pWdrRawColBuf,      0, sizeof(RK_U16) * RAW_BLK_SIZE);                                   


	
    // pWdrRawResult // Result: 32x32n*2B
    nChunkSize         = sizeof(RK_U16) * RAW_BLK_SIZE * RAW_BLK_SIZE*RAW_WIN_NUM;
    pWdrRawResult      = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count
    if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrRawResult !\n");
#endif
        return ret;
    }



    //////////////////////////////////////////////////////////////////////////
    ////---- Processing Block(#i, #j)
    chunkIdx_nr       = 1; // odd-even init
    currentBufIdx_wdr = 1; // odd-even init
    for (int i=0; i < mRawHgt; i += blkHgt)
    {
        for (int j=0; j < mRawWid; j += blkWid)
        {
            // num Block32x32 of Current Chunk
            numBlocks   = (MIN(blkWid, mRawWid-j) + RAW_BLK_SIZE - 1) / RAW_BLK_SIZE; 


            // Block(#i,#j) Valid Range // block(row, col) 32x32n
            nBaseBlkRow = i;
            nBaseBlkCol = j;
            nBaseBlkHgt = blkHgt;
            nBaseBlkWid = blkWid;
            rects[mBasePicNum].rowUseful = nBaseBlkRow;// Rect Useful
            rects[mBasePicNum].colUseful = nBaseBlkCol;
            rects[mBasePicNum].hgtUseful = MIN(nBaseBlkHgt, mRawHgt - nBaseBlkRow);
            rects[mBasePicNum].widUseful = MIN(nBaseBlkWid, mRawWid - nBaseBlkCol);
            // Bounding Rectangle of RawBase // Maybe Include Invalid Data
            nBaseBlkRow_border    = nBaseBlkRow - RAW_BLK_BORDER;
            nBaseBlkCol_border    = nBaseBlkCol - RAW_BLK_BORDER;
            nBaseBlkCol_border    = ALIGN_4PIXEL_START(nBaseBlkCol_border);
            nBaseBlkHgt_border    = nBaseBlkHgt + 2 * RAW_BLK_EXTEND_ROW;
            nBaseBlkWid_border    = nBaseBlkWid + 2 * RAW_BLK_EXTEND_COL;
            nBaseBlkWid_border    = ALIGN_4PIXEL_WIDTH(nBaseBlkWid_border);
            nBaseBlkStride_border = (nBaseBlkWid + 2 * RAW_BLK_EXTEND_COL) * sizeof(RK_U16); // stride in DSP
            rects[mBasePicNum].rowExtend    = nBaseBlkRow_border; // Rect Extend
            rects[mBasePicNum].colExtend    = nBaseBlkCol_border;
            rects[mBasePicNum].hgtExtend    = nBaseBlkHgt_border;
            rects[mBasePicNum].widExtend    = nBaseBlkWid_border;
            rects[mBasePicNum].strideExtend = nBaseBlkStride_border;
            // Valid Data Rectangle in RawBase // Only Include Valid Data
            nBaseBlkRow_4p    = MAX(nBaseBlkRow_border, 0);
            nBaseBlkCol_4p    = MAX(nBaseBlkCol_border, 0);
            nBaseBlkHgt_4p    = MIN(nBaseBlkHgt_border - (nBaseBlkRow_4p - nBaseBlkRow_border), mRawHgt - nBaseBlkRow_4p);
            nBaseBlkWid_4p    = MIN(nBaseBlkWid_border - (nBaseBlkCol_4p - nBaseBlkCol_border), mRawWid - nBaseBlkCol_4p);
            nBaseBlkCol_4p    = ALIGN_4PIXEL_START(nBaseBlkCol_4p); // 4PixelAlign Rectangle for DMA
            nStartCol_4p      = nBaseBlkCol_4p - nBaseBlkCol_4p;
            nBaseBlkWid_4p    = ALIGN_4PIXEL_WIDTH(nStartCol_4p + nBaseBlkWid_4p);
            rects[mBasePicNum].rowValid = nBaseBlkRow_4p;// Rect Valid
            rects[mBasePicNum].colValid = nBaseBlkCol_4p;
            rects[mBasePicNum].hgtValid = nBaseBlkHgt_4p;
            rects[mBasePicNum].widValid = nBaseBlkWid_4p;

            // DMA
            pDdrRawBase = (RK_U16*)((RK_U8*)pRawSrcs[mBasePicNum] 
                        + rects[mBasePicNum].rowValid * mRawStride 
                        + rects[mBasePicNum].colValid * 5/4);
            chunkIdx_nr = (chunkIdx_nr + 1) & 0x1; // odd-even
            pDspRawBase = (RK_U16*)((RK_U8*)pRawBlkChunks[chunkIdx_nr][mBasePicNum] 
                        + (rects[mBasePicNum].rowValid - rects[mBasePicNum].rowExtend) * rects[mBasePicNum].strideExtend 
                        + (rects[mBasePicNum].colValid - rects[mBasePicNum].colExtend) * sizeof(RK_U16));
//            memset(pRawBlkChunks[chunkIdx_nr][mBasePicNum], 0, sizeof(RK_U16) * (blkHgt+2*4) * (blkWid+2*8));
            RKDMA_ReadRaw10bit2DSP((U32)pDdrRawBase, (U32)pDspRawBase, 
                rects[mBasePicNum].widValid, rects[mBasePicNum].hgtValid, 
                mRawStride, rects[mBasePicNum].strideExtend, 
                rects[mBasePicNum].colValid);

            // BaseBlock
            for (int n=0; n < numBlocks; n++)
            {
                // Half Block Size
                nHalfBlkHgt = MIN(nBaseBlkHgt, RAW_BLK_SIZE) / 2;   // Half Block Hgt in Raw
                nHalfBlkWid = MIN(nBaseBlkWid - n * RAW_BLK_SIZE, RAW_BLK_SIZE) / 2;   // Half Block Wid in Raw

                // Block32x32 Center Row in Raw -> in Luma
                pRawBlkPoints[mBasePicNum][n*2+0] = (RK_F32)((nBaseBlkRow + nHalfBlkHgt) / 2);
                pRawBlkPoints[mBasePicNum][n*2+1] = (RK_F32)((nBaseBlkCol + nHalfBlkWid + n * RAW_BLK_SIZE) / 2);

                // Ref
                for (int k=0; k < mRawFileNum; k++)
                {
                    if (k != mBasePicNum)
                    {
                        // Project in Luma
                        ret = PerspectProject(pHomographyMatrix[k], pRawBlkPoints[mBasePicNum]+2*n, pRawBlkPoints[k]+2*n);

                        // Center in LumaRef Block#n -> TopLeft in RawRef Block#n
                        pRawBlkPoints[k][n*2+0] = (RK_F32)(ROUND_I32(pRawBlkPoints[k][n*2+0]) * 2 - nHalfBlkHgt);
                        pRawBlkPoints[k][n*2+1] = (RK_F32)(ROUND_I32(pRawBlkPoints[k][n*2+1]) * 2 - nHalfBlkWid);
                        // Round
//                         pRawBlkPoints[k][n*2+0] = (RK_F32)ROUND_I32(pRawBlkPoints[k][n*2+0]);
//                         pRawBlkPoints[k][n*2+1] = (RK_F32)ROUND_I32(pRawBlkPoints[k][n*2+1]);
                    }
                }

                // Center in LumaBase Block#n -> TopLeft in RawBase Block#n
                pRawBlkPoints[mBasePicNum][n*2+0] = pRawBlkPoints[mBasePicNum][n*2+0] * 2 - nHalfBlkHgt;
                pRawBlkPoints[mBasePicNum][n*2+1] = pRawBlkPoints[mBasePicNum][n*2+1] * 2 - nHalfBlkWid;
            }

            for (int k=0; k < mRawFileNum; k++)
            {
                if (k != mBasePicNum)
                {
                    // Find Bounding Rectangle of numBlocks-ProjPoints
                    minRefBlocksRow = +0xFFFF;  // min Ref Row in 4-ImageCornerBlocks
                    maxRefBlocksRow = -0xFFFF;  // max Ref Row in 4-ImageCornerBlocks
                    minRefBlocksCol = +0xFFFF;  // min Ref Col in 4-ImageCornerBlocks
                    maxRefBlocksCol = -0xFFFF;  // max Ref Col in 4-ImageCornerBlocks
                    for (int n=0; n < numBlocks; n++)
                    {
                        // min&max Row of numBlocks-ProjPoints
                        if (pRawBlkPoints[k][n*2+0] < minRefBlocksRow)
                        {
                            minRefBlocksRow = (RK_S32)pRawBlkPoints[k][n*2+0];
                        }
                        if (pRawBlkPoints[k][n*2+0] > maxRefBlocksRow)
                        {
                            maxRefBlocksRow = (RK_S32)pRawBlkPoints[k][n*2+0];
                        }
                        // min&max Col of numBlocks-ProjPoints
                        if (pRawBlkPoints[k][n*2+1] < minRefBlocksCol)
                        {
                            minRefBlocksCol = (RK_S32)pRawBlkPoints[k][n*2+1];
                        }
                        if (pRawBlkPoints[k][n*2+1] > maxRefBlocksCol)
                        {
                            maxRefBlocksCol = (RK_S32)pRawBlkPoints[k][n*2+1];
                        }
                    } // for n

                    // Compute ProjWinSize
                    maxProjRowDist = maxRefBlocksRow - minRefBlocksRow; // max Ref ProjRowDist in 4-ImageCornerBlocks
                    maxProjColDist = maxRefBlocksCol - minRefBlocksCol; // max Ref ProjColDist in 4-ImageCornerBlocks

                    //////////////////////////////////////////////////////////////////////////
                    //---- DMA: RawRef(DDR10bit->DSP16bit)
                    // Block(#i,#j) Valid Range
                    rects[k].rowUseful = minRefBlocksRow;// Rect Useful
                    rects[k].colUseful = minRefBlocksCol;
                    rects[k].hgtUseful = MIN(maxProjRowDist + nBaseBlkHgt,  mRawHgt - minRefBlocksRow);
                    rects[k].widUseful = MIN(maxProjColDist + RAW_BLK_SIZE, mRawWid - minRefBlocksCol);
                    // Bounding Rectangle of RawRef
                    nRefBlkRow_border    = minRefBlocksRow - RAW_BLK_BORDER; // Maybe Include Invalid Data
                    nRefBlkCol_border    = minRefBlocksCol - RAW_BLK_BORDER;
                    nRefBlkCol_border    = ALIGN_4PIXEL_START(nRefBlkCol_border);
                    nRefBlkHgt_border    = maxProjRowDist + nBaseBlkHgt + 2*RAW_BLK_BORDER;//MIN(blkHgt, mRawHgt-nBaseBlkRow) + maxProjRowDist + 2*RAW_BLK_BORDER;
                    nRefBlkWid_border    = maxProjColDist + RAW_BLK_SIZE + 2*(minRefBlocksCol-nRefBlkCol_border);//MIN(blkWid, mRawWid-nBaseBlkCol) + maxProjColDist + 2*RAW_BLK_BORDER;
                    nRefBlkWid_border    = ALIGN_4PIXEL_WIDTH(nRefBlkWid_border);
                    nRefBlkStride_border = nRefBlkWid_border * sizeof(RK_U16); // stride in DSP
                    rects[k].rowExtend    = nRefBlkRow_border; // Rect Extend
                    rects[k].colExtend    = nRefBlkCol_border;
                    rects[k].hgtExtend    = nRefBlkHgt_border;
                    rects[k].widExtend    = nRefBlkWid_border;
                    rects[k].strideExtend = nRefBlkStride_border;
                    // Valid Data Rectangle in RawRef
                    nRefBlkRow_4p    = MAX(nRefBlkRow_border, 0);// Only Include Valid Data
                    nRefBlkCol_4p    = MAX(nRefBlkCol_border, 0);
                    nRefBlkHgt_4p    = MIN(nRefBlkHgt_border - (nRefBlkRow_4p - nRefBlkRow_border), mRawHgt - nRefBlkRow_4p);
                    nRefBlkWid_4p    = MIN(nRefBlkWid_border - (nRefBlkCol_4p - nRefBlkCol_border), mRawWid - nRefBlkCol_4p);
                    nRefBlkCol_4p    = ALIGN_4PIXEL_START(nRefBlkCol_4p);
                    nStartCol_4p     = nRefBlkCol_4p - nRefBlkCol_4p;
                    nRefBlkWid_4p    = ALIGN_4PIXEL_WIDTH(nStartCol_4p + nRefBlkWid_4p);
                    rects[k].rowValid = nRefBlkRow_4p;// Rect Valid
                    rects[k].colValid = nRefBlkCol_4p;
                    rects[k].hgtValid = nRefBlkHgt_4p;
                    rects[k].widValid = nRefBlkWid_4p;
                    // Rect Useful Constraint
                    nRowCrop = rects[k].rowValid - rects[k].rowUseful;
                    rects[k].rowUseful += MAX(0, nRowCrop);
                    rects[k].hgtUseful -= MAX(0, nRowCrop);
                    nColCrop = rects[k].colValid - rects[k].colUseful;
                    rects[k].colUseful += MAX(0, nColCrop);
                    rects[k].widUseful -= MAX(0, nColCrop);

                    // DMA
                    pDdrRawRef = (RK_U16*)((RK_U8*)pRawSrcs[k] 
                               + rects[k].rowValid * mRawStride 
                               + rects[k].colValid * 5/4); // stride = mThumbStride
                    pDspRawRef = (RK_U16*)((RK_U8*)pRawBlkChunks[chunkIdx_nr][k]
                               + (rects[k].rowValid - rects[k].rowExtend) * rects[k].strideExtend 
                               + (rects[k].colValid - rects[k].colExtend) * sizeof(RK_U16));
//                    memset(pRawBlkChunks[chunkIdx_nr][k], 0, sizeof(RK_U16) * (blkHgt+2*4) * (blkWid+2*8));
                    RKDMA_ReadRaw10bit2DSP((U32)pDdrRawRef, (U32)pDspRawRef, 
                        rects[k].widValid, rects[k].hgtValid, 
                        mRawStride, rects[k].strideExtend, 
                        rects[k].colValid);
                } // if k
            } // for k


            // Temporal Denoise (Modify)
            TemporalDenoise_Modify(pRawBlkChunks[chunkIdx_nr], numBlocks, rects, 
                mRawFileNum, mBasePicNum, pRawBlkPoints, 
                MotionDetectTable, mIspGain, mBlackLevel,
                pRawDstChunk);

            //////////////////////////////////////////////////////////////////////////
            // TemporalDenoise Result
            /*/ DMA
            pDdrRawDst = (RK_U16*)((RK_U8*)pRawDst + rects[mBasePicNum].rowUseful * mRawStride + rects[mBasePicNum].colUseful * 5/4); // stride = mThumbStride
            RKDMA_WriteRaw16bit2DDR((U32)pRawDstChunk, (U32)pDdrRawDst, rects[mBasePicNum].widUseful, rects[mBasePicNum].hgtUseful, 
                rects[mBasePicNum].widUseful*sizeof(RK_U16), mRawStride, rects[mBasePicNum].colUseful);
            //*/

//*
            // BayerWDR
            //////////////////////////////////////////////////////////////////////////
            //// Bayer WDR
            // Buf Idx
            currentBufIdx_wdr = (currentBufIdx_wdr + 1) & 0x1; // odd-even for LoadData
            anotherBufIdx_wdr = (currentBufIdx_wdr + 1) & 0x1; // odd-even for Process
            // Rect Info
            pWdrRawBlockRect[currentBufIdx_wdr][0] = rects[mBasePicNum].rowUseful; // =i;
            pWdrRawBlockRect[currentBufIdx_wdr][1] = rects[mBasePicNum].colUseful; // =j;
            pWdrRawBlockRect[currentBufIdx_wdr][2] = rects[mBasePicNum].hgtUseful;
            pWdrRawBlockRect[currentBufIdx_wdr][3] = rects[mBasePicNum].widUseful;

            // Fill Block32x64 from TemporalDenoise
            CopyBlockData(pRawDstChunk, pWdrRawBlockBuf[currentBufIdx_wdr] + 2 * nWdrBufWid + 1,  
                blkWid, blkHgt, blkWid*2, nWdrBufWid*2);

            // Fill 2-TopExternalRows from RowBuf
            CopyBlockData(pWdrRawRowBuf + j, pWdrRawBlockBuf[currentBufIdx_wdr], 
                nWdrBufWid, 2, nRowsBufWid*2, nWdrBufWid*2);

            // Fill 1-LeftCol from ColBuf
            CopyBlockData(pWdrRawColBuf, pWdrRawBlockBuf[currentBufIdx_wdr]+2*nWdrBufWid, 
                1, RAW_BLK_SIZE, 2, nWdrBufWid*2);

            // Update 1-RightCol
            CopyBlockData(pWdrRawBlockBuf[currentBufIdx_wdr]+2*nWdrBufWid+RAW_BLK_SIZE*RAW_WIN_NUM, pWdrRawColBuf, 
                1, RAW_BLK_SIZE, nWdrBufWid*2, 2);

            // 
            if (i==0 && j==0)
            {
                // First Block of Image
                continue;
            }
            else
            {
                // Fill 1-RightCol from AnotherBuf
                CopyBlockData(pWdrRawBlockBuf[currentBufIdx_wdr] + 2*nWdrBufWid + 1, 
                              pWdrRawBlockBuf[anotherBufIdx_wdr] + 2*nWdrBufWid + RAW_BLK_SIZE*RAW_WIN_NUM+1, 
                              1, RAW_BLK_SIZE, nWdrBufWid*2, nWdrBufWid*2);


                // Update 2-TopRows to RowBuf
                CopyBlockData(pWdrRawBlockBuf[anotherBufIdx_wdr] + RAW_BLK_SIZE*nWdrBufWid, 
                              pWdrRawRowBuf + pWdrRawBlockRect[anotherBufIdx_wdr][1], 
                              nWdrBufWid, 2, nWdrBufWid*2, nRowsBufWid*2);


                //////////////////////////////////////////////////////////////////////////
                // BayerWDR
                wdr_process_block(
                    pWdrRawBlockRect[anotherBufIdx_wdr][1],//rects[mBasePicNum].colUseful,       // [in] x of block in Raw 
					pWdrRawBlockRect[anotherBufIdx_wdr][0],//rects[mBasePicNum].rowUseful,       // [in] y of block in Raw 
					pWdrRawBlockRect[anotherBufIdx_wdr][3],//rects[mBasePicNum].widUseful,       // [in] min(64, valid)    
					pWdrRawBlockRect[anotherBufIdx_wdr][2],//rects[mBasePicNum].hgtUseful,       // [in] min(32, valid)   
                    ((mRawWid+128)/256+1),	            // [in] (raw_width+128)/256+1 floor((4164+128)/256)+1
                    66,	                                // [in] buffer stride         66
                    64,		                            // [in] picture stride        64
                    pWdrRawBlockBuf[anotherBufIdx_wdr], // [in] input buf             34x66*2B
          		#if WDR_WEIGHT_TRANSPOSE
					pWdrThumbWgtTable1,
					//pWdrThumbWgtTable + 9*256,
		  		#else
                    pWdrThumbWgtTable,	                // [in] thumb weight table,   9x256*2B
                #endif
                    pWdrScaleTable,                     // [in] tabale[expouse_times] 961*2B
                    pWdrGainMat,                        // [out] Gain Matrix          32x64*2B
                    pWdrRawResult,                      // [out] WDR result           32x64*2B
                    pWdrLeftRight);                     // [in] 32x16*2B byte space   2K store 32 line left and right, align 16, actually 9 valid..
#ifdef CEVA_CHIP_CODE_BAYERWDR // #if 0-WDR Bypass, 1-WDR
				// DMA                                                                                                                  
				if ( (i == 0) || (i == 32 && j == 0))
				{                                                                                                                       
				    // DspRow[1:31]->DdrRow[0:30]                                                                                       
				    pDspWdrBuf = (RK_U16*)(pWdrRawResult + RAW_BLK_SIZE*RAW_WIN_NUM);   // DspRow[1:31]                                 
				    pDdrRawDst = (RK_U16*)((RK_U8*)pRawDst                                                                              
				        + pWdrRawBlockRect[anotherBufIdx_wdr][0] * mRawStride           // DdrRow[0:30]                                 
				        + pWdrRawBlockRect[anotherBufIdx_wdr][1] * 5/4);                                                                
				    RKDMA_WriteRaw16bit2DDR((U32)pDspWdrBuf, (U32)pDdrRawDst,                                                           
				        pWdrRawBlockRect[anotherBufIdx_wdr][3], pWdrRawBlockRect[anotherBufIdx_wdr][2] - 1, // w, h-1                   
				        pWdrRawBlockRect[anotherBufIdx_wdr][3]*sizeof(RK_U16), mRawStride, pWdrRawBlockRect[anotherBufIdx_wdr][1]);     
				}                                                                                                                       
				else                                                                                                                    
				{                                                                                                                       
				    // DspRow[0:31]->DdrRow[32N-1:32(N+1)-2]                                                                            
				    // pDspWdrBuf = pWdrRawResult;                                      // DspRow[0:31]                                 
				    pDdrRawDst = (RK_U16*)((RK_U8*)pRawDst                                                                              
				        + (pWdrRawBlockRect[anotherBufIdx_wdr][0] - 1) * mRawStride     // DdrRow[32N-1:32(N+1)-2]                      
				        + pWdrRawBlockRect[anotherBufIdx_wdr][1] * 5/4);                                                                
				    RKDMA_WriteRaw16bit2DDR((U32)pWdrRawResult, (U32)pDdrRawDst,                                                        
				        pWdrRawBlockRect[anotherBufIdx_wdr][3], pWdrRawBlockRect[anotherBufIdx_wdr][2], // w, h                         
				        pWdrRawBlockRect[anotherBufIdx_wdr][3]*sizeof(RK_U16), mRawStride, pWdrRawBlockRect[anotherBufIdx_wdr][1]);     
				}                                                                                                                       
#else
				// DMA
				pDdrRawDst = (RK_U16*)((RK_U8*)pRawDst
					+ pWdrRawBlockRect[anotherBufIdx_wdr][0] * mRawStride
					+ pWdrRawBlockRect[anotherBufIdx_wdr][1] * 5/4); // stride = mThumbStride
				RKDMA_WriteRaw16bit2DDR((U32)pWdrRawResult, (U32)pDdrRawDst,
					pWdrRawBlockRect[anotherBufIdx_wdr][3], pWdrRawBlockRect[anotherBufIdx_wdr][2], // w, h
					pWdrRawBlockRect[anotherBufIdx_wdr][3]*sizeof(RK_U16), mRawStride, pWdrRawBlockRect[anotherBufIdx_wdr][1]);
				///
#endif

            } // WDR
//*/


        } // for j
    } // for i

//*
    //// Processing Last Block(#end, #end)
    // BayerWDR
    wdr_process_block(
        pWdrRawBlockRect[anotherBufIdx_wdr][1],//rects[mBasePicNum].colUseful,       // [in] x of block in Raw 
		pWdrRawBlockRect[anotherBufIdx_wdr][0],//rects[mBasePicNum].rowUseful,       // [in] y of block in Raw 
		pWdrRawBlockRect[anotherBufIdx_wdr][3],//rects[mBasePicNum].widUseful,       // [in] min(64, valid)    
		pWdrRawBlockRect[anotherBufIdx_wdr][2],//rects[mBasePicNum].hgtUseful,       // [in] min(32, valid)   
        ((mRawWid+128)/256+1),	            // [in] (raw_width+128)/256+1 floor((4164+128)/256)+1
        66,	                                // [in] buffer stride         66
        64,		                            // [in] picture stride        64
        pWdrRawBlockBuf[currentBufIdx_wdr], // [in] input buf             34x66*2B
	#if WDR_WEIGHT_TRANSPOSE
		pWdrThumbWgtTable1,
		//pWdrThumbWgtTable + 9*256,
	#else
		pWdrThumbWgtTable,	                // [in] thumb weight table,   9x256*2B
	#endif
        pWdrScaleTable,                     // [in] tabale[expouse_times] 961*2B
        pWdrGainMat,                        // [out] Gain Matrix          32x64*2B
        pWdrRawResult,                      // [out] WDR result           32x64*2B
        pWdrLeftRight);                     // [in] 32x16*2B byte space   2K store 32 line left and right, align 16, actually 9 valid..
        //pWdrRight);                         // [in] 32x16*2B byte space
#ifdef CEVA_CHIP_CODE_BAYERWDR // #if 0-WDR Bypass, 1-WDR
    // DMA
     pDdrRawDst = (RK_U16*)((RK_U8*)pRawDst
    	+ (pWdrRawBlockRect[currentBufIdx_wdr][0] - 1 )* mRawStride
		+ pWdrRawBlockRect[currentBufIdx_wdr][1] * 5/4); // stride = mThumbStride
     RKDMA_WriteRaw16bit2DDR((U32)pWdrRawResult, (U32)pDdrRawDst,                                                    
    	pWdrRawBlockRect[currentBufIdx_wdr][3], pWdrRawBlockRect[currentBufIdx_wdr][2], // w, h
		pWdrRawBlockRect[currentBufIdx_wdr][3]*sizeof(RK_U16), mRawStride, pWdrRawBlockRect[currentBufIdx_wdr][1]);
#else
     // DMA
	 pDdrRawDst = (RK_U16*)((RK_U8*)pRawDst
		+ pWdrRawBlockRect[currentBufIdx_wdr][0] * mRawStride
		+ pWdrRawBlockRect[currentBufIdx_wdr][1] * 5/4); // stride = mThumbStride
	 RKDMA_WriteRaw16bit2DDR((U32)pWdrRawResult, (U32)pDdrRawDst,
		pWdrRawBlockRect[currentBufIdx_wdr][3], pWdrRawBlockRect[currentBufIdx_wdr][2], // w, h
		pWdrRawBlockRect[currentBufIdx_wdr][3]*sizeof(RK_U16), mRawStride, pWdrRawBlockRect[currentBufIdx_wdr][1]);
	 //
#endif
//*/

    //
    return ret;

} // Enhancer_Modify()


/************************************************************************/
// Func: classMFNR::MFNR_Process()
// Desc: MFNR Process
//   In: 
//  Out: pRawDst        - [out] RawDst data pointer
// 
// Date: Revised by yousf 20160822
// 
/*************************************************************************/
CODE_MFNR_EX
int classMFNR::MFNR_Process(RK_RawType* pRawDst)
{
    //
    int     ret = 0; // return value
#if MY_DEBUG_PRINTF == 1
    printf("classMFNR::MFNR_Process()\n");
#endif
    //////////////////////////////////////////////////////////////////////////
    int     nChunkSize;                 // Memory Size for  DSP Malloc
    int     nDspMem_NextModuleResetPos; // Next Module DSP Memory Reset Position

    // DSP Memory addr#0
    mDspMem_UsedCount = 0;  // Method-2: use MemoryArray, DSP Memory Array Used Count
    mDspMem_ResetPos  = 0;  // Method-2: use MemoryArray, DSP Memory Reset Position

    //////////////////////////////////////////////////////////////////////////
    ////==== DSP Malloc: pHomographyMatrix & pWdrThumbWgtTable addr in DSP
    // pHomographyMatrix
    nChunkSize = sizeof(RK_F32) * 9;
    for (int k=0; k < mRawFileNum; k++)
    {
        pHomographyMatrix[k] = (RK_F32*)&dspMemoryArray[mDspMem_UsedCount];
        mDspMem_UsedCount   += nChunkSize; // current used count
        if (mDspMem_UsedCount > DSP_MEM_SIZE)
        {
#if MY_DEBUG_PRINTF == 1
            printf("Failed to Allocate pHomographyMatrix[%d] !\n", k);
#endif
            return ret;
        }
    }
	mDspMem_UsedCount = ALIGN_SET(mDspMem_UsedCount, 64);
    // pWdrThumbWgtTable // Thumb Weight Table: 9x256*2B
    nChunkSize         = sizeof(RK_U16) * 9 * 256 * 2;// 
    // add by zxy for store the  256x16*2B
    nChunkSize        += sizeof(RK_U16) * 16 * 256 * 2;// 
    pWdrThumbWgtTable  = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += nChunkSize; // current used count

	// Trans
    pWdrThumbWgtTable1  = (RK_U16*)&dspMemoryArray[mDspMem_UsedCount];
    mDspMem_UsedCount += sizeof(RK_U16) * 16 * 256 * 2; // current used count


	if (mDspMem_UsedCount > DSP_MEM_SIZE)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Allocate pWdrThumbWgtTable !\n");
#endif
        return ret;
    }
    // DSP Memory Reuse Operation
    mDspMem_ResetPos           = mDspMem_UsedCount; // BaseAddress for Next Variable
    nDspMem_NextModuleResetPos = mDspMem_ResetPos;  // BaseAddress for Process Module-2: Enhancer Interface

    //////////////////////////////////////////////////////////////////////////
    //// Process Module-1: Register Interface 
#if BYPASS_Register == DISABLE_BYPASS
    // Register: FeatureDetect & FeatureFilter & CoarseMatching & FineMatching & ComputeHomography
    ret = Register();
    if (ret)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Register !\n");
#endif
        return ret;
    }

    // Write Register Result
//     ret = Register_BypassWrite(pHomographyMatrix, mRawFileNum);
//     if (ret)
//     {
// #if MY_DEBUG_PRINTF == 1
//         printf("Failed to Register_BypassWrite !\n");
// #endif
//         return ret;
//     }
    
#elif BYPASS_Register == ENABLE_BYPASS  // Bypass
    // Read Register Result
//     ret = Register_BypassRead(mRawFileNum, pHomographyMatrix);
//     if (ret)
//     {
// #if MY_DEBUG_PRINTF == 1
//         printf("Failed to Register_BypassWrite !\n");
// #endif
//         return ret;
//     }

#endif


    //////////////////////////////////////////////////////////////////////////
    //// Process Module-2: Enhancer Interface
    // DSP Addr Reset
    mDspMem_ResetPos = nDspMem_NextModuleResetPos;
#if BYPASS_Enhancer == DISABLE_BYPASS
    // Enhancer: TemporalDenoise & BayerWDR & SpatialDenoise
#if USE_MODIFY_ENHANCER == 0
    ret = Enhancer(pRawDst);
#else
    ret = Enhancer_Modify(pRawDst);
#endif
    if (ret)
    {
#if MY_DEBUG_PRINTF == 1
        printf("Failed to Enhancer !\n");
#endif
        return ret;
    }

#elif BYPASS_Register == ENABLE_BYPASS  // Bypass
    // TODO ...

#endif


    //
    return ret;

} // classMFNR::MFNR_Process()



/************************************************************************/
// Func: classMFNR::MFNR_UnInit()
// Desc: MFNR UnInit
//   In: 
//  Out: 
// 
// Date: Revised by yousf 20160804
// 
/*************************************************************************/
CODE_MFNR_EX
int classMFNR::MFNR_UnInit(void)
{
    //
    int     ret = 0; // return value
#if MY_DEBUG_PRINTF == 1
    printf("classMFNR::MFNR_UnInit()\n");
#endif


    //
    return ret;

} // classMFNR::MFNR_UnInit()



CODE_MFNR_EX
int RK_MFNR_Processor(RK_InputParams* pInParams, RK_ControlParams* pCtrlParams, RK_RawType* pRawDst)
{
	//
	int     ret = 0; // return value
#if MY_DEBUG_PRINTF == 1
	printf("RK_MFNR_Processor()\n");
#endif

	// DSP Memory Init
	memset(g_DspBuf, 0xff, DSP_MEM_SIZE);
	g_mfnrProcessor.dspMemoryArray = g_DspBuf;

	g_mfnrProcessor.MFNR_Init(pInParams, pCtrlParams);
	g_mfnrProcessor.MFNR_Process((RK_RawType*)pRawDst);
	g_mfnrProcessor.MFNR_UnInit();

	//
	return ret;
}
//////////////////////////////////////////////////////////////////////////




